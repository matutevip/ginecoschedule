// Sin necesidad de declaraci√≥n global para este caso

import { useState, useEffect, useCallback, useRef } from "react";
import { useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import {
  DndContext, 
  DragEndEvent,
  DragStartEvent,
  DragOverEvent,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors
} from '@dnd-kit/core';
import { Switch } from "@/components/ui/switch";
import { 
  AlertDialog,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogCancel,
  AlertDialogAction,
} from "@/components/ui/alert-dialog";
import { TimePicker } from "@/components/ui/time-picker";
import {
  type Appointment,
  type ScheduleConfig,
  insertAppointmentSchema,
} from "@shared/schema";
import {
  startOfWeek,
  endOfWeek,
  eachDayOfInterval,
  format,
  isWithinInterval,
  isSameDay,
  isSameMonth,
  addWeeks,
  isAfter,
  isBefore,
  startOfMonth,
  endOfMonth,
  subMonths,
  addMonths,
  startOfDay,
  endOfDay,
} from "date-fns";
import { es } from "date-fns/locale";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { motion } from "framer-motion";
import {
  Loader2,
  LogOut,
  Search,
  Trash2,
  Trash,
  Filter,
  FilterX,
  ChevronLeft,
  ChevronRight,
  Mail,
  Phone,
  Settings,
  ArrowUpDown,
  FileText,
  ArrowLeft,
  Clock,
  User,
  StickyNote,
  Bell,
  Edit,
  Stethoscope,
  CalendarClock,
  Building2,
  Plus,
  Check,
  CheckCircle,
  Laptop,
  MoreVertical,
  X,
  ListFilter,
  RefreshCw,
  Timer,
  XCircle,
  Calendar as CalendarIcon2, CalendarIcon
} from "lucide-react";

import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import { AppointmentsCarousel } from "../components/admin/appointments-carousel";
import { PatientMessageConfig } from "../components/admin/patient-message-config";
import { GoogleCalendarStatus } from "../components/admin/google-calendar-status";
import { StatisticsDashboard } from "../components/admin/statistics-dashboard";
import { StatisticsPreview } from "../components/admin/statistics-preview";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { ClinicalHistory } from "../components/admin/clinical-history";
import { AccountSettings } from "../components/admin/account-settings";
import { DraggableAppointment, isFortyMinService } from "../components/admin/draggable-appointment";
import { CalendarAppointment } from "../components/admin/calendar-appointment";
import { DroppableTimeSlot } from "../components/admin/droppable-time-slot";
import { NewQuickAppointmentForm } from "../components/admin/new-quick-appointment-form";

interface InsertAppointment {
  patientName: string;
  email: string;
  phone: string;
  serviceType: string;
  obraSocial: string;
  isFirstTime: boolean;
  notes: string;
  appointmentTime: Date;
  patientId?: number;
}

interface PatientMessage {
  id: number;
  title: string;
  content: string;
  displayDuration: number;
  daysToShow: number;
}

const sortOptions = [
  { value: "date-desc", label: "Fecha (m√°s cercana)" },
  { value: "date-asc", label: "Fecha (m√°s lejana)" },
  { value: "name-asc", label: "Nombre (A-Z)" },
  { value: "name-desc", label: "Nombre (Z-A)" },
];

export default function Admin() {
  const [_, navigate] = useLocation();
  const { toast } = useToast();

  const [currentTime, setCurrentTime] = useState<Date>(new Date());
  
  // Inicializar la semana seleccionada para mostrar el mi√©rcoles m√°s cercano
  const findClosestWednesday = () => {
    const today = new Date();
    const dayOfWeek = today.getDay(); // 0 = domingo, 3 = mi√©rcoles
    let daysToAdd;
    
    if (dayOfWeek < 3) {
      // Si estamos antes del mi√©rcoles, vamos al pr√≥ximo mi√©rcoles
      daysToAdd = 3 - dayOfWeek;
    } else if (dayOfWeek > 3) {
      // Si estamos despu√©s del mi√©rcoles, vamos al pr√≥ximo mi√©rcoles
      daysToAdd = 10 - dayOfWeek; // 7 d√≠as + (3 - dayOfWeek)
    } else {
      // Si hoy es mi√©rcoles
      daysToAdd = 0;
    }
    
    const closestWednesday = new Date(today);
    closestWednesday.setDate(today.getDate() + daysToAdd);
    return closestWednesday;
  };
  
  const [selectedWeek, setSelectedWeek] = useState<Date>(findClosestWednesday());
  const [viewMode, setViewMode] = useState<"list" | "calendar">("calendar");
  
  // Registrar cambios de modo de vista para depuraci√≥n
  useEffect(() => {
    console.log("Modo de vista cambiado a:", viewMode);
  }, [viewMode]);
  const [inlineEditId, setInlineEditId] = useState<number | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [obraSocialFilter, setObraSocialFilter] = useState<string>("all");
  const [selectedAppointments, setSelectedAppointments] = useState<number[]>(
    [],
  );
  const [editingAppointment, setEditingAppointment] =
    useState<Appointment | null>(null);
  const [deleteConfirmId, setDeleteConfirmId] = useState<number | null>(null);
  const [cancelConfirmId, setCancelConfirmId] = useState<number | null>(null);
  const [noShowConfirmId, setNoShowConfirmId] = useState<number | null>(null);
  const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
  const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
  const [showScheduleSettings, setShowScheduleSettings] = useState(false);
  // Used to track appointment details when viewing or performing actions
  const [selectedAppointment, setSelectedAppointment] =
    useState<Appointment | null>(null);
  const [showNewAppointment, setShowNewAppointment] = useState(false);
  
  // Estados para manejar los d√≠as eventuales y sus horarios espec√≠ficos
  const [showOccasionalDayTimeDialog, setShowOccasionalDayTimeDialog] = useState(false);
  const [newOccasionalDay, setNewOccasionalDay] = useState<string | null>(null);
  const [occasionalDayStartTime, setOccasionalDayStartTime] = useState<string>("09:00");
  const [occasionalDayEndTime, setOccasionalDayEndTime] = useState<string>("12:00");

  const form = useForm({
    resolver: zodResolver(insertAppointmentSchema),
    defaultValues: {
      patientName: "",
      email: "",
      phone: "",
      serviceType: "Consulta",
      obraSocial: "Particular",
      isFirstTime: false,
      notes: "",
      appointmentTime: new Date(),
    },
  });

  // Objeto √∫nico para manejar la informaci√≥n de selecci√≥n de horarios
  interface SelectedSlot {
    date: Date;
    time: string;
    hour: number;
    minute: number;
    fullDateTime: Date;
  }
  
  // Estado para la selecci√≥n de horarios
  const [selectedSlot, setSelectedSlot] = useState<SelectedSlot | null>(null);
  
  // Mantener estos estados para compatibilidad con el c√≥digo existente
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedTime, setSelectedTime] = useState<string | null>(null);
  
  // Nuevo estado para controlar qu√© slot tiene el formulario r√°pido abierto
  const [quickFormSlot, setQuickFormSlot] = useState<{timeStr: string, date: Date, appointment?: Appointment} | null>(null);
  

  
  // Registrar cambios en quickFormSlot para depuraci√≥n
  useEffect(() => {
    console.log('quickFormSlot cambi√≥:', quickFormSlot);
  }, [quickFormSlot]);
  
  // Referencias para compatibilidad con c√≥digo existente
  const selectedSlotRef = useRef<{date: Date, time: string, hour: number, minute: number} | null>(null);
  const openingFromSlotRef = useRef<boolean>(false);
  const formUpdateTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Reset form when opening new appointment dialog
  useEffect(() => {
    // Solo se ejecuta cuando se abre el di√°logo
    if (!showNewAppointment) return;
    
    console.log("Modal opened with selectedSlot:", selectedSlot);
    console.log("openingFromSlotRef:", openingFromSlotRef.current);
    
    // Verificar si estamos en el caso donde se abre el formulario directo sin seleccionar slot
    // Esta es la ruta cuando se hace clic en el bot√≥n "Nuevo Turno" sin seleccionar un horario espec√≠fico
    const isOpeningFromButton = !openingFromSlotRef.current;
    
    if (isOpeningFromButton) {
      console.log("Opening form from button without slot selection");
      
      // Fallback a la fecha actual si no hay slot o tiempo seleccionado
      const currentDate = new Date();
      
      form.reset({
        patientName: "",
        email: "",
        phone: "",
        serviceType: "Consulta",
        obraSocial: "Particular",
        isFirstTime: false,
        notes: "",
        appointmentTime: currentDate,
      });
    }
    
    // IMPORTANTE: No hacemos nada m√°s en este efecto cuando se est√° abriendo el formulario
    // desde un slot (handleSlotSelect) porque ya se encarg√≥ de configurar el formulario
    // usando resetFormWithTime y updateFormDateTime 
    
    // Limpiar la bandera cuando se cierre el formulario
    return () => {
      if (!showNewAppointment) {
        openingFromSlotRef.current = false;
      }
    };
  }, [showNewAppointment, form]);
  const [editedConfig, setEditedConfig] = useState<ScheduleConfig | undefined>(
    undefined,
  );
  const [upcomingAppointmentsPage, setUpcomingAppointmentsPage] = useState(0);
  const [appointmentsPage, setAppointmentsPage] = useState(0);
  const [vacationStart, setVacationStart] = useState<Date | undefined>(
    undefined,
  );
  const [vacationEnd, setVacationEnd] = useState<Date | undefined>(undefined);
  const [patientMessages, setPatientMessages] = useState<PatientMessage[]>([]);
  const [dateFilter, setDateFilter] = useState<{
    from: Date | undefined;
    to: Date | undefined;
  }>({
    from: undefined,
    to: undefined,
  });
  const [calendarMonth, setCalendarMonth] = useState<Date>(new Date());
  const [sortOption, setSortOption] = useState<string>("date-desc");
  const [showClinicalHistory, setShowClinicalHistory] = useState<number | null>(
    null,
  );
  const [availableDates, setAvailableDates] = useState<Date[]>([]);
  const [activeAppointmentDrag, setActiveAppointmentDrag] = useState<Appointment | null>(null);
  
  // Estados para gestionar los d√≠as bloqueados
  const [blockedDays, setBlockedDays] = useState<{id: number, date: string, reason: string}[]>([]);
  const [showBlockDayDialog, setShowBlockDayDialog] = useState(false);
  const [dayToBlock, setDayToBlock] = useState<Date | null>(null);
  const [blockReason, setBlockReason] = useState("");
  
  // Estado para gestionar la confirmaci√≥n de eliminaci√≥n de d√≠as eventuales
  const [dayToRemove, setDayToRemove] = useState<string | null>(null);
  const [showRemoveConfirmDialog, setShowRemoveConfirmDialog] = useState(false);

  // Configurar sensores para drag and drop
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor)
  );

  const scheduleForm = useForm({
    defaultValues: {
      startTime: "",
      endTime: "",
      workDays: [],
      vacationPeriods: [],
    },
  });

  const { isLoading: checkingAuth, error: authError } = useQuery({
    queryKey: ["/api/admin/check"],
    retry: false,
  });

  useEffect(() => {
    if (authError) {
      navigate("/admin/login");
    }
  }, [authError, navigate]);

  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 60000);
    
    // Eventos personalizados para manejar acciones desde el formulario r√°pido
    const handleCancelConfirm = (e: CustomEvent) => {
      setCancelConfirmId(e.detail);
    };
    
    const handleNoShowConfirm = (e: CustomEvent) => {
      setNoShowConfirmId(e.detail);
    };
    
    window.addEventListener('set-cancel-confirm-id', handleCancelConfirm as EventListener);
    window.addEventListener('set-no-show-confirm-id', handleNoShowConfirm as EventListener);
    
    return () => {
      clearInterval(timer);
      window.removeEventListener('set-cancel-confirm-id', handleCancelConfirm as EventListener);
      window.removeEventListener('set-no-show-confirm-id', handleNoShowConfirm as EventListener);
    };
  }, []);

  useEffect(() => {
    if (editingAppointment) {
      const appointmentTime = new Date(editingAppointment.appointmentTime);

      const formData: InsertAppointment = {
        patientName: editingAppointment.patientName,
        email: editingAppointment.email,
        phone: editingAppointment.phone,
        serviceType: editingAppointment.serviceType || "Consulta",
        obraSocial: editingAppointment.obraSocial || "Particular",
        isFirstTime: editingAppointment.isFirstTime || false,
        notes: editingAppointment.notes || "",
        appointmentTime: appointmentTime,
      };

      if (editingAppointment.patientId) {
        formData.patientId = editingAppointment.patientId;
      }

      // Set the selected date and time for the UI
      setSelectedDate(appointmentTime);

      // Make sure we use the correct time format with minutes if needed - use padStart for hours too
      const hours = appointmentTime.getHours();
      const minutes = appointmentTime.getMinutes();
      const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes === 0 ? '00' : minutes.toString().padStart(2, '0')}`;
      setSelectedTime(formattedTime);

      console.log("Setting time for editing appointment:", formattedTime, "Date:", appointmentTime.toISOString());

      // Make sure this appointment time is considered available in the time slot selection
      // by updating availableDates to include this date
      if (availableDates.every(date => !isSameDay(date, appointmentTime))) {
        setAvailableDates(prev => [...prev, appointmentTime]);
      }

      // Reset form with the appointment data AFTER setting the UI elements
      setTimeout(() => {
        form.reset(formData);

        // Double-check that the value was set correctly after a short delay
        setTimeout(() => {
          const currentValue = form.getValues("appointmentTime");
          console.log("Form reset completed with appointment time:", currentValue);

          // If needed, force set it again
          if (currentValue && (new Date(currentValue).getHours() !== hours || 
                              new Date(currentValue).getMinutes() !== minutes)) {
            console.log("Time wasn't set correctly, forcing update");
            form.setValue("appointmentTime", appointmentTime, {
              shouldValidate: true,
              shouldDirty: true,
              shouldTouch: true,
            });
          }
        }, 50);
      }, 0);
    }
  }, [editingAppointment, form, availableDates]);

  const { data: scheduleConfig } =
    useQuery<ScheduleConfig>({
      queryKey: ["/api/admin/schedule-config"],
      enabled: !checkingAuth && !authError,
    });

  useEffect(() => {
    if (scheduleConfig && !editedConfig) {
      setEditedConfig(scheduleConfig);
    }
  }, [scheduleConfig]);

  const { data: appointmentsData, isLoading: loadingAppointments } = useQuery<Appointment[]>({
    queryKey: ["/api/admin/appointments"],
    enabled: !checkingAuth && !authError,
    refetchInterval: 30000, // Refetch every 30 seconds
    staleTime: 10000, // Consider data stale after 10 seconds
  });

  const appointments = appointmentsData || [];
  
  // Log detallado de las citas recibidas
  useEffect(() => {
    console.log("Citas recibidas del servidor:", appointments.length);
    console.log("¬øEst√° cargando?", loadingAppointments);
    if (appointments.length > 0) {
      console.log("Primera cita:", appointments[0]);
    }
  }, [appointments, loadingAppointments]);
  
  // Log para confirmar que las citas se est√°n recibiendo correctamente
  useEffect(() => {
    console.log("Estado de datos:", {
      checkingAuth,
      authError,
      appointmentsLoaded: !!appointmentsData,
      appointmentsCount: appointmentsData?.length || 0
    });
  }, [appointmentsData, checkingAuth, authError]);
  
  // Logging para depuraci√≥n
  useEffect(() => {
    if (appointmentsData) {
      console.log(`Citas recibidas del servidor: ${appointmentsData.length}`, appointmentsData);
      
      // Depuraci√≥n adicional para el filtrado de citas
      setTimeout(() => {
        console.log("Estado del filtro de obra social:", obraSocialFilter);
        console.log("Estado del filtro de b√∫squeda:", searchQuery);
        console.log("Estado del filtro de fechas:", dateFilter);
        
        // Verificar filtrado utilizando misma l√≥gica que filteredAppointments
        const tempFiltered = appointmentsData.filter((appointment) => {
          // Filtro de b√∫squeda (nombre o email)
          const searchLower = searchQuery.toLowerCase();
          const matchesSearch =
            appointment.patientName.toLowerCase().includes(searchLower) ||
            (appointment.email ? appointment.email.toLowerCase().includes(searchLower) : false);

          // Filtro de obra social
          const matchesObraSocial =
            obraSocialFilter === "all" || 
            (obraSocialFilter === "Particular" && (!appointment.obraSocial || appointment.obraSocial === "Particular")) ||
            (appointment.obraSocial === obraSocialFilter);

          // Filtro de rango de fechas
          const appointmentDate = new Date(appointment.appointmentTime);
          const matchesDateRange =
            (!dateFilter.from ||
              isAfter(appointmentDate, startOfDay(dateFilter.from))) &&
            (!dateFilter.to || isBefore(appointmentDate, endOfDay(dateFilter.to)));

          // Registrar resultados de filtrado para cada cita
          console.log(`Cita ID ${appointment.id}:`, { 
            nombre: appointment.patientName,
            matchesSearch, 
            matchesObraSocial,
            obraSocialValue: appointment.obraSocial,
            matchesDateRange,
            appointmentDate: appointmentDate.toISOString()
          });

          return matchesSearch && matchesObraSocial && matchesDateRange;
        });
        
        console.log(`Despu√©s de filtrar: ${tempFiltered.length} citas pasan los filtros.`);
      }, 500);
    }
  }, [appointmentsData, obraSocialFilter, searchQuery, dateFilter]);

  const editMutation = useMutation({
    mutationFn: async ({ id, data }: { id: number; data: Partial<InsertAppointment> }) => {
      const res = await apiRequest("PATCH", `/api/appointments/${id}`, data);
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || "Error al actualizar el turno");
      }
      return res.json();
    },
    onSuccess: (updatedAppointment: Appointment) => {
      // Update the cache with the edited appointment
      queryClient.setQueryData<Appointment[]>(["/api/admin/appointments"], (old) => {
        return old 
          ? old.map(apt => apt.id === updatedAppointment.id ? updatedAppointment : apt)
          : [updatedAppointment];
      });

      setEditingAppointment(null);
      toast({
        title: "Turno actualizado",
        description: "El turno ha sido actualizado exitosamente.",
      });

      // Reset form and selection states
      form.reset();
      setSelectedDate(null);
      setSelectedTime(null);
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const noShowMutation = useMutation({
    mutationFn: async (id: number | null) => {
      if (!id) return;
      console.log(`Intentando marcar como 'no show' el turno con ID: ${id}`);
      const res = await apiRequest("PATCH", `/api/appointments/${id}`, {
        status: 'no_show',
        noShowAt: new Date()
      });
      if (!res.ok) {
        throw new Error("Error al marcar la ausencia del paciente");
      }
      return id; // Devolvemos el ID para saber qu√© turno se marc√≥
    },
    onSuccess: (markedId) => {
      console.log(`Turno ${markedId} marcado como 'no show' exitosamente`);
      queryClient.invalidateQueries({ queryKey: ["/api/admin/appointments"] });
      toast({
        title: "Ausencia registrada",
        description: "Se ha registrado la ausencia del paciente exitosamente.",
      });
      setNoShowConfirmId(null); // Cerramos el di√°logo de confirmaci√≥n
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Mutaci√≥n para marcar cita como asistida
  const attendedMutation = useMutation({
    mutationFn: async (id: number | null) => {
      if (!id) return;
      console.log(`Intentando marcar como 'asisti√≥' el turno con ID: ${id}`);
      const res = await apiRequest("PATCH", `/api/appointments/${id}`, {
        status: 'attended',
        attendedAt: new Date()
      });
      if (!res.ok) {
        throw new Error("Error al marcar la asistencia del paciente");
      }
      return id; // Devolvemos el ID para confirmar la operaci√≥n
    },
    onSuccess: (markedId) => {
      console.log(`Turno ${markedId} marcado como 'asisti√≥' exitosamente`);
      queryClient.invalidateQueries({ queryKey: ["/api/admin/appointments"] });
      // Refrescar estad√≠sticas tambi√©n
      queryClient.invalidateQueries({ queryKey: ["/api/admin/statistics"] });
      toast({
        title: "Asistencia registrada",
        description: "Se ha registrado la asistencia del paciente exitosamente.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const cancelMutation = useMutation({
    mutationFn: async (id: number | null) => {
      if (!id) return;
      console.log(`Intentando cancelar el turno con ID: ${id}`);
      const res = await apiRequest("POST", `/api/admin/appointments/${id}/cancel`);
      if (!res.ok) {
        throw new Error("Error al cancelar el turno");
      }
      return id; // Devolvemos el ID para saber qu√© turno se cancel√≥
    },
    onSuccess: (cancelledId) => {
      console.log(`Turno ${cancelledId} cancelado exitosamente`);
      queryClient.invalidateQueries({ queryKey: ["/api/admin/appointments"] });
      toast({
        title: "Turno cancelado",
        description: "El turno ha sido cancelado exitosamente. Se ha enviado una notificaci√≥n al paciente.",
      });
      setCancelConfirmId(null); // Cerramos el di√°logo de confirmaci√≥n
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const deleteMutation = useMutation({
    mutationFn: async (id: number | null) => {
      if (!id) return;
      console.log(`Intentando eliminar el turno con ID: ${id}`);
      const res = await apiRequest("DELETE", `/api/appointments/${id}`);
      if (!res.ok) {
        throw new Error("Error al eliminar el turno");
      }
      return id; // Devolvemos el ID para saber qu√© turno se elimin√≥
    },
    onSuccess: (deletedId) => {
      console.log(`Turno ${deletedId} eliminado exitosamente`);
      queryClient.invalidateQueries({ queryKey: ["/api/admin/appointments"] });
      toast({
        title: "Turno eliminado",
        description: "El turno ha sido eliminado exitosamente.",
      });
      setSelectedAppointments([]);
      setDeleteConfirmId(null); // Cerramos el di√°logo de confirmaci√≥n
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const bulkDeleteMutation = useMutation({
    mutationFn: async (ids: number[]) => {
      await Promise.all(
        ids.map((id) => apiRequest("DELETE", `/api/appointments/${id}`)),
      );
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/admin/appointments"] });
      toast({
        title: "Turnos eliminados",
        description: `${selectedAppointments.length} turnos han sido eliminados exitosamente.`,
      });
      setSelectedAppointments([]);
      setShowBulkDeleteConfirm(false);
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Mutaci√≥n para enviar el resumen diario de citas
  const sendDailySummaryMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/admin/send-daily-summary");
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Error al enviar el resumen diario");
      }
      return res.json();
    },
    onSuccess: () => {
      toast({
        title: "Resumen enviado",
        description: "El resumen diario de citas ha sido enviado exitosamente.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });
  
  // Consulta para obtener los d√≠as bloqueados
  const fetchBlockedDays = useCallback(async () => {
    try {
      // Usar apiRequest para incluir credenciales de sesi√≥n
      const response = await apiRequest("GET", "/api/admin/blocked-days");
      
      if (response.ok) {
        const data = await response.json();
        console.log("D√≠as bloqueados obtenidos:", data);
        
        // Asegurarse de que el formato es correcto
        const formattedData = Array.isArray(data) ? data.map(item => ({
          id: item.id,
          date: item.date,
          reason: item.reason
        })) : [];
        
        setBlockedDays(formattedData);
      } else {
        console.error("Error al obtener d√≠as bloqueados:", response.status, response.statusText);
      }
    } catch (error) {
      console.error('Error al obtener d√≠as bloqueados:', error);
    }
  }, []);
  
  // Cargar d√≠as bloqueados al iniciar
  useEffect(() => {
    fetchBlockedDays();
  }, [fetchBlockedDays]);
  
  // Mutaci√≥n para crear un d√≠a bloqueado
  const createBlockedDayMutation = useMutation({
    mutationFn: async ({ date, reason }: { date: Date, reason: string }) => {
      const res = await apiRequest("POST", "/api/admin/blocked-days", {
        date: format(date, "yyyy-MM-dd"),
        reason
      });
      
      if (!res.ok) {
        throw new Error("Error al bloquear el d√≠a");
      }
      
      return res.json();
    },
    onSuccess: () => {
      fetchBlockedDays(); // Actualizar la lista de d√≠as bloqueados
      toast({
        title: "D√≠a bloqueado",
        description: "El d√≠a ha sido bloqueado exitosamente en la agenda",
      });
      // Limpiar estado
      setShowBlockDayDialog(false);
      setDayToBlock(null);
      setBlockReason("");
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    }
  });
  
  // Mutaci√≥n para eliminar un d√≠a bloqueado
  const deleteBlockedDayMutation = useMutation({
    mutationFn: async (id: number) => {
      const res = await apiRequest("DELETE", `/api/admin/blocked-days/${id}`);
      
      if (!res.ok) {
        throw new Error("Error al desbloquear el d√≠a");
      }
      
      return id;
    },
    onSuccess: () => {
      fetchBlockedDays(); // Actualizar la lista de d√≠as bloqueados
      toast({
        title: "D√≠a desbloqueado",
        description: "El d√≠a ha sido desbloqueado exitosamente en la agenda",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    }
  });
  
  // Funci√≥n para manejar la confirmaci√≥n del bloqueo de d√≠a
  const handleBlockDay = () => {
    if (dayToBlock && blockReason.trim()) {
      createBlockedDayMutation.mutate({
        date: dayToBlock,
        reason: blockReason
      });
    } else {
      toast({
        title: "Error",
        description: "Por favor ingrese un motivo para bloquear el d√≠a",
        variant: "destructive",
      });
    }
  };

  const logoutMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/admin/logout");
      if (!res.ok) {
        throw new Error("Error al cerrar sesi√≥n");
      }
      return res.json();
    },
    onSuccess: () => {
      // Limpiar todas las consultas en cach√© para forzar nuevas verificaciones de autenticaci√≥n
      queryClient.clear();
      
      // Invalidar espec√≠ficamente la consulta de verificaci√≥n de autenticaci√≥n
      queryClient.invalidateQueries({ queryKey: ["/api/admin/check"] });
      
      // Invalidar todas las consultas relacionadas con datos de administraci√≥n
      queryClient.invalidateQueries({ queryKey: ["/api/admin"] });
      
      toast({
        title: "Sesi√≥n cerrada",
        description: "Ha cerrado sesi√≥n exitosamente",
      });
      
      // Redireccionar a la p√°gina de inicio
      navigate("/admin/login");
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const reminderMutation = useMutation({
    mutationFn: async (id: number) => {
      const res = await apiRequest(
        "POST",
        `/api/admin/appointments/${id}/send-reminder`,
      );
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || "Error al enviar el recordatorio");
      }
      return res.json();
    },
    onSuccess: () => {
      toast({
        title: "Recordatorio enviado",
        description: "El recordatorio ha sido enviado exitosamente.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const updateScheduleMutation = useMutation({
    mutationFn: async (config: Partial<ScheduleConfig>) => {
      // Crear una copia profunda para no modificar el objeto original
      const finalConfig = {
        ...scheduleConfig,
        ...config,
      };
      
      // Manejar per√≠odos de vacaciones
      if (config.vacationPeriods) {
        finalConfig.vacationPeriods = config.vacationPeriods.map((period) => ({
          start: new Date(period.start).toISOString(),
          end: new Date(period.end).toISOString(),
        }));
      } else if (scheduleConfig?.vacationPeriods) {
        finalConfig.vacationPeriods = scheduleConfig.vacationPeriods;
      } else {
        finalConfig.vacationPeriods = [];
      }
      
      // Manejar d√≠as eventuales - asegurarse de que es un array v√°lido
      if (config.occasionalWorkDays) {
        console.log("üîÑ Actualizando d√≠as eventuales:", config.occasionalWorkDays);
        finalConfig.occasionalWorkDays = config.occasionalWorkDays;
      }
      
      // Enviar la solicitud al servidor
      console.log("üîÑ Enviando configuraci√≥n al servidor:", finalConfig);
      const res = await apiRequest(
        "PATCH",
        "/api/admin/schedule-config",
        finalConfig,
      );
      
      if (!res.ok) {
        const error = await res.json();
        throw new Error(
          error.message || "Error al actualizar la configuraci√≥n",
        );
      }
      
      const responseData = await res.json();
      console.log("‚úÖ Configuraci√≥n actualizada correctamente:", responseData);
      return responseData;
    },
    onSuccess: (data) => {
      console.log("üîÑ Actualizando estado local y cache...");
      
      // Forzar una actualizaci√≥n inmediata de todas las consultas relacionadas
      queryClient.invalidateQueries({
        queryKey: ["admin-schedule-config"],
      });
      
      queryClient.invalidateQueries({
        queryKey: ["appointments"],
      });
      
      // Actualizar la configuraci√≥n p√∫blica
      fetch("/api/schedule-config", { 
        cache: "no-store",
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        }
      })
      .then(res => res.json())
      .then(data => console.log("‚úÖ Configuraci√≥n p√∫blica actualizada:", data))
      .catch(err => console.error("‚ùå Error actualizando configuraci√≥n p√∫blica:", err));
      
      // Si est√°bamos eliminando un d√≠a eventual, cerrar el di√°logo
      if (dayToRemove) {
        setShowRemoveConfirmDialog(false);
        setDayToRemove(null);
        
        toast({
          title: "D√≠a eventual eliminado",
          description: "El d√≠a eventual ha sido eliminado correctamente del calendario",
        });
        
        // Forzar una recarga completa de la p√°gina para asegurar que todo se actualice
        setTimeout(() => {
          window.location.reload();
        }, 1000);
      } else {
        // Mensaje general de √©xito
        toast({
          title: "Configuraci√≥n actualizada",
          description:
            "La configuraci√≥n de horarios ha sido actualizada exitosamente.",
        });
      }
    },
    onError: (error: Error) => {
      console.error("‚ùå Error durante la actualizaci√≥n:", error);
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Mutation para sincronizar manualmente con Google Calendar
  const syncCalendarMutation = useMutation({
    mutationFn: async () => {
      console.log("Iniciando sincronizaci√≥n manual con Google Calendar");
      const res = await apiRequest("POST", "/api/admin/google-calendar-sync", {});
      if (!res.ok) {
        const errorData = await res.json();
        console.log("Error en sincronizaci√≥n:", errorData);
        throw new Error(errorData.message || "Error al sincronizar con Google Calendar");
      }
      const data = await res.json();
      console.log("Respuesta de sincronizaci√≥n:", data);
      return data;
    },
    onSuccess: (data) => {
      console.log("Sincronizaci√≥n exitosa:", data);
      queryClient.invalidateQueries({ queryKey: ['/api/admin/appointments'] });
      toast({
        title: "Sincronizaci√≥n completada",
        description: data.message || `Sincronizaci√≥n exitosa. Se actualizaron ${data.updated} citas.`
      });
    },
    onError: (error: Error) => {
      console.log("Error en syncCalendarMutation:", error);
      toast({
        title: "Error de sincronizaci√≥n",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  const createAppointmentMutation = useMutation({
    mutationFn: async (data: InsertAppointment) => {
      console.log("Creating appointment with data:", data);
      const res = await apiRequest("POST", "/api/appointments", data);
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || "Error al crear el turno");
      }
      return res.json();
    },
    onSuccess: (newAppointment: Appointment) => {
      // Update the cache with the new appointment
      queryClient.setQueryData<Appointment[]>(["/api/admin/appointments"], (old) => {
        return old ? [newAppointment, ...old] : [newAppointment];
      });

      setShowNewAppointment(false);
      toast({
        title: "Turno creado",
        description: "El turno ha sido creado exitosamente.",
      });

      // Reset form and selection states
      form.reset();
      setSelectedDate(null);
      setSelectedTime(null);
    },
    onError: (error: Error) => {
      console.log("Error creating appointment:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Error al procesar el turno",
        variant: "destructive"
      });
    }
  });

  const saveMessageMutation = useMutation({
    mutationFn: async (message: Omit<PatientMessage, "id">) => {
      const res = await apiRequest(
        "POST",
        "/api/admin/patient-messages",
        message,
      );

      const contentType = res.headers.get("content-type");
      if (!contentType || !contentType.includes("application/json")) {
        throw new Error("Error al procesar la respuesta del servidor");
      }

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || "Error al guardar el mensaje");
      }
      return res.json();
    },
    onSuccess: (newMessage) => {
      queryClient.invalidateQueries({
        queryKey: ["/api/admin/patient-messages"],
      });
      setPatientMessages((prevMessages) => [...prevMessages, newMessage]);
      toast({
        title: "Mensaje guardado",
        description: "El mensaje ha sido guardado exitosamente.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const deleteMessageMutation = useMutation({
    mutationFn: async (id: number) => {
      const res = await apiRequest(
        "DELETE",
        `/api/admin/patient-messages/${id}`,
      );
      if (!res.ok) {
        throw new Error("Error al eliminar el mensaje");
      }
    },
    onSuccess: (_, id) => {
      queryClient.invalidateQueries({
        queryKey: ["/api/admin/patient-messages"],
      });
      setPatientMessages((prevMessages) =>
        prevMessages.filter((message) => message.id !== id),
      );
      toast({
        title: "Mensaje eliminado",
        description: "El mensaje ha sido eliminado exitosamente.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const handleLogout = () => {
    setShowLogoutConfirm(true);
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedAppointments(appointments.map((app) => app.id));
    } else {
      setSelectedAppointments([]);
    }
  };

  // Estado para los datos en edici√≥n
  const [editingRowData, setEditingRowData] = useState<{
    id: number;
    patientName: string;
    email: string;
    phone: string;
    serviceType: string;
    obraSocial: string;
    isFirstTime: boolean;
    notes: string;
    appointmentTime: Date;
  } | null>(null);
  
  // Funci√≥n para iniciar la edici√≥n en l√≠nea
  const handleInlineEdit = (id: number) => {
    const appointment = appointments.find(apt => apt.id === id);
    if (!appointment) return;
    
    // Si ya estamos editando otra cita, cancelar esa edici√≥n primero
    if (inlineEditId !== null && inlineEditId !== id) {
      setInlineEditId(null);
      setEditingRowData(null);
    }
    
    // Si no estamos en modo edici√≥n, iniciarla
    if (inlineEditId !== id) {
      console.log("Iniciando edici√≥n para la cita:", id);
      setInlineEditId(id);
      setEditingRowData({
        id: appointment.id,
        patientName: appointment.patientName || "",
        email: appointment.email || "",
        phone: appointment.phone || "",
        serviceType: appointment.serviceType || "Consulta",
        obraSocial: appointment.obraSocial || "Particular",
        isFirstTime: appointment.isFirstTime || false,
        notes: appointment.notes || "",
        appointmentTime: new Date(appointment.appointmentTime)
      });
    }
    // Ya no cerramos el modo edici√≥n al hacer clic en la celda nuevamente
  };
  
  // Funci√≥n para guardar todos los cambios
  const saveRowEdits = async () => {
    if (!editingRowData) return;
    
    const { id, ...data } = editingRowData;
    
    // Normalizar el horario si es necesario
    let minutes = data.appointmentTime.getMinutes();
    if (minutes % 20 !== 0 && minutes % 30 !== 0) {
      // Normalizar los minutos al valor m√°s cercano (0, 20, 30)
      const normalizedMinutes = (() => {
        if (minutes < 10) return 0;
        if (minutes < 25) return 20;
        if (minutes < 45) return 30;
        return 0; // Si es >= 45, volvemos a 0 y se incrementar√≠a la hora
      })();
      
      // Ajustar la hora si es necesario
      let newHour = data.appointmentTime.getHours();
      if (minutes >= 45 && normalizedMinutes === 0) {
        newHour = (newHour + 1) % 24;
      }
      
      // Crear una nueva fecha con los minutos normalizados
      const normalizedDate = new Date(data.appointmentTime);
      normalizedDate.setHours(newHour, normalizedMinutes, 0, 0);
      data.appointmentTime = normalizedDate;
      
      toast({
        title: "Horario ajustado",
        description: `El horario se ha ajustado a ${format(data.appointmentTime, "HH:mm", { locale: es })} hs para cumplir con los intervalos permitidos`,
      });
      
      // Actualizar el estado de edici√≥n para reflejar la normalizaci√≥n
      minutes = normalizedMinutes;
    }
    
    // Para servicios especiales, verificar compatibilidad
    const is40MinService = isFortyMinService(data.serviceType);
    if (is40MinService && minutes !== 0 && minutes !== 20 && minutes !== 30) {
      toast({
        title: "Horario inv√°lido para servicios especiales",
        description: "Los servicios DIU y Terapia solo pueden comenzar a las XX:00, XX:20 o XX:30",
        variant: "destructive"
      });
      return;
    }
    
    // Verificar disponibilidad del horario
    const isValidTimeSlot = isTimeSlotAvailable(
      data.appointmentTime,
      data.appointmentTime.getHours(),
      data.appointmentTime.getMinutes(),
      appointments.filter(apt => apt.id !== id)
    );
    
    if (!isValidTimeSlot) {
      toast({
        title: "Error",
        description: "El horario seleccionado no est√° disponible",
        variant: "destructive"
      });
      return;
    }
    
    try {
      
      console.log("Guardando cambios con nueva fecha y hora:", format(data.appointmentTime, "yyyy-MM-dd HH:mm:ss"));
      
      await editMutation.mutateAsync({
        id,
        data
      });
      
      // Cerrar el modo de edici√≥n despu√©s de guardar exitosamente
      setInlineEditId(null);
      setEditingRowData(null);
      
      toast({
        title: "Cambios guardados",
        description: "La cita ha sido actualizada correctamente",
      });
    } catch (error) {
      console.error("Error al actualizar cita:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Error al actualizar la cita",
        variant: "destructive"
      });
    }
  };
  
  // Funci√≥n para cancelar la edici√≥n
  const cancelRowEdit = () => {
    setInlineEditId(null);
    setEditingRowData(null);
  };
  
  // Componente para el campo editable en l√≠nea
  const EditableCell = ({ 
    value, 
    field, 
    isEditing,
    appointment
  }: { 
    value: string | null, 
    field: string,
    isEditing: boolean,
    appointment?: Appointment
  }) => {
    const safeValue = value || "";
    
    // Si no estamos en modo edici√≥n, mostrar solo el valor
    if (!isEditing || !editingRowData) {
      return <span>{safeValue}</span>;
    }
    
    // Si es campo de fecha, mostrar un DatePicker con TimePicker
    if (field === 'appointmentTime') {
      // Verificar si es un servicio de 40 minutos
      const is40MinService = isFortyMinService(editingRowData.serviceType || "");
      
      // Convertir la fecha de edici√≥n actual a un string para poder validar el horario
      const currentHour = editingRowData.appointmentTime.getHours();
      const currentMinute = editingRowData.appointmentTime.getMinutes();
      const currentTimeStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
      
      // Obtener la lista de citas existentes (excluyendo la que estamos editando)
      const otherAppointments = appointments.filter(apt => apt.id !== editingRowData.id);
      
      // Verificar si el horario actual est√° disponible
      const isCurrentTimeAvailable = isTimeSlotAvailable(
        editingRowData.appointmentTime,
        currentHour,
        currentMinute,
        otherAppointments
      );
      
      return (
        <div className="flex flex-col items-start gap-2">
          <div className="flex items-center gap-2 w-full">
            <Popover>
              <PopoverTrigger asChild>
                <Button
                  variant="outline"
                  className={cn(
                    "h-8 py-1 text-sm justify-start font-normal",
                    !isCurrentTimeAvailable && "border-destructive text-destructive"
                  )}
                >
                  <CalendarIcon2 className="mr-2 h-4 w-4" />
                  {format(editingRowData.appointmentTime, "PPP", { locale: es })}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0" align="start">
                <Calendar
                  mode="single"
                  selected={editingRowData.appointmentTime}
                  onSelect={(newDate) => {
                    if (newDate) {
                      // Mantener la hora actual
                      const currentDate = editingRowData.appointmentTime;
                      newDate.setHours(
                        currentDate.getHours(),
                        currentDate.getMinutes(),
                        0,
                        0
                      );
                      // Verificar disponibilidad antes de actualizar
                      const isAvailable = isTimeSlotAvailable(
                        newDate,
                        newDate.getHours(),
                        newDate.getMinutes(),
                        otherAppointments
                      );
                      
                      if (!isAvailable) {
                        toast({
                          title: "Horario ocupado",
                          description: "El horario seleccionado ya est√° ocupado en esta fecha",
                          variant: "destructive"
                        });
                        return;
                      }
                      
                      setEditingRowData({
                        ...editingRowData,
                        appointmentTime: newDate
                      });
                    }
                  }}
                  initialFocus
                />
              </PopoverContent>
            </Popover>
            
            <Popover>
              <PopoverTrigger asChild>
                <Button
                  variant="outline"
                  className={cn(
                    "h-8 py-1 text-sm justify-start font-normal",
                    !isCurrentTimeAvailable && "border-destructive text-destructive"
                  )}
                >
                  <Clock className="mr-2 h-4 w-4" />
                  {format(editingRowData.appointmentTime, "HH:mm", { locale: es })}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-3" align="start">
                <TimePicker 
                  date={editingRowData.appointmentTime} 
                  setDate={(newDate) => {
                    if (newDate) {
                      // Normalizar los minutos si no son v√°lidos
                      const newMinutes = newDate.getMinutes();
                      
                      // Verificar si el nuevo horario es v√°lido (m√∫ltiplo de 20 o 30 minutos)
                      if (newMinutes % 20 !== 0 && newMinutes % 30 !== 0) {
                        // Normalizar los minutos al valor m√°s cercano
                        const normalizedMinutes = (() => {
                          if (newMinutes < 10) return 0;
                          if (newMinutes < 25) return 20;
                          if (newMinutes < 45) return 30;
                          return 0; // Si es >= 45, volvemos a 0 y se incrementar√≠a la hora si fuera necesario
                        })();
                        
                        // Crear una nueva fecha con los minutos normalizados
                        const normalizedDate = new Date(newDate);
                        normalizedDate.setMinutes(normalizedMinutes);
                        
                        // Actualizar newDate con los minutos normalizados
                        newDate = normalizedDate;
                        
                        toast({
                          title: "Horario ajustado",
                          description: `El horario se ha ajustado a ${format(newDate, "HH:mm", { locale: es })} hs`,
                        });
                      }
                      
                      // Verificar reglas especiales para servicios de 40 minutos
                      // Usar los nuevos minutos ya normalizados
                      const updatedMinutes = newDate.getMinutes();
                      if (is40MinService && updatedMinutes !== 0 && updatedMinutes !== 20 && updatedMinutes !== 30) {
                        // Para servicios de 40 minutos, normalizar a 0, 20, o 30
                        const compatibleMinute = (() => {
                          if (updatedMinutes <= 10) return 0;
                          if (updatedMinutes <= 25) return 20;
                          if (updatedMinutes <= 40) return 30;
                          return 0; // Si es > 40, ajustar a 0 de la siguiente hora
                        })();
                        
                        // Si necesitamos ajustar a la siguiente hora cuando es > 40
                        let newHour = newDate.getHours();
                        if (updatedMinutes > 40 && compatibleMinute === 0) {
                          newHour = (newHour + 1) % 24;
                        }
                        
                        // Crear nueva fecha con los minutos compatibles
                        const compatibleDate = new Date(newDate);
                        compatibleDate.setHours(newHour, compatibleMinute, 0, 0);
                        
                        // Reemplazar la fecha original con la versi√≥n compatible
                        newDate = compatibleDate;
                        
                        toast({
                          title: "Horario ajustado para servicio especial",
                          description: `El horario se ha ajustado a ${format(newDate, "HH:mm", { locale: es })} hs para ser compatible con ${editingRowData.serviceType}`,
                        });
                      }
                      
                      // Verificar disponibilidad
                      const isAvailable = isTimeSlotAvailable(
                        newDate,
                        newDate.getHours(),
                        newDate.getMinutes(),
                        otherAppointments
                      );
                      
                      if (!isAvailable) {
                        toast({
                          title: "Horario ocupado",
                          description: "El horario seleccionado ya est√° ocupado",
                          variant: "destructive"
                        });
                        return;
                      }
                      
                      setEditingRowData({
                        ...editingRowData,
                        appointmentTime: newDate
                      });
                    }
                  }} 
                  // Filtrar las horas disponibles para la fecha seleccionada
                  getAvailableMinutes={(hour) => {
                    // Crear una fecha de prueba con esta hora para verificar minutos disponibles
                    const testDate = new Date(editingRowData.appointmentTime);
                    testDate.setHours(hour, 0, 0, 0);
                    
                    // Verificar cada posible minuto (0, 20, 30) para esta hora
                    return [0, 20, 30].filter(minute => {
                      // Ajustar el testDate con el minuto actual
                      testDate.setMinutes(minute);
                      
                      // Verificar si este slot est√° disponible (excluyendo la cita actual)
                      return isTimeSlotAvailable(
                        testDate,
                        hour,
                        minute,
                        otherAppointments,
                        editingRowData.id
                      );
                    });
                  }}
                />
              </PopoverContent>
            </Popover>
          </div>
          
          {/* Mostrar informaci√≥n sobre los horarios disponibles y estado */}
          <div className="flex flex-col gap-1 text-xs">
            <p className={cn(
              "text-muted-foreground",
              !isCurrentTimeAvailable && "text-destructive"
            )}>
              {isCurrentTimeAvailable 
                ? "Horario disponible" 
                : "¬°Atenci√≥n! Este horario est√° ocupado por otra cita"}
            </p>
            <p className="text-muted-foreground">
              Los horarios deben ser m√∫ltiplos de 20 o 30 minutos (09:00, 09:20, 09:30).
              {is40MinService && " Para DIU o Terapia solo se permiten horarios espec√≠ficos (00, 20 o 30 min)."}
            </p>
          </div>
        </div>
      );
    }
    
    // Para el campo de servicio, mostrar un select
    if (field === 'serviceType') {
      // Obtener las citas actuales (excluyendo la que estamos editando)
      const otherAppointments = appointments.filter(apt => apt.id !== editingRowData.id);
      
      // Verificar si el tiempo actual es compatible con servicios de 40 minutos
      const currentMinutes = editingRowData.appointmentTime.getMinutes();
      const compatibleWith40Min = currentMinutes === 0 || currentMinutes === 20 || currentMinutes === 30;
      
      // Verificar disponibilidad del tiempo actual
      const isTimeAvailable = isTimeSlotAvailable(
        editingRowData.appointmentTime,
        editingRowData.appointmentTime.getHours(),
        editingRowData.appointmentTime.getMinutes(),
        otherAppointments
      );
      
      return (
        <div className="flex flex-col gap-1">
          <Select 
            value={editingRowData.serviceType}
            onValueChange={(value) => {
              // Verificar si estamos cambiando a un servicio de 40 minutos
              const isChangingTo40Min = 
                value === "Extracci√≥n & Colocaci√≥n de DIU" || 
                value === "Terapia de Ginecolog√≠a Regenerativa";
              
              // Si cambiamos a 40 min pero el horario no es compatible, mostrar advertencia
              if (isChangingTo40Min && !compatibleWith40Min) {
                toast({
                  title: "Advertencia de horario",
                  description: "Los servicios de DIU y Terapia solo pueden comenzar a las XX:00, XX:20 o XX:30",
                  variant: "destructive"
                });
              }
              
              // Actualizar el valor de todas formas para permitir al usuario ajustar el horario despu√©s
              setEditingRowData({...editingRowData, serviceType: value});
            }}
          >
            <SelectTrigger className={cn(
              "h-8 text-xs",
              !isTimeAvailable && "border-destructive text-destructive"
            )}>
              <SelectValue placeholder={editingRowData.serviceType || "Seleccionar"} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="Consulta">Consulta</SelectItem>
              <SelectItem value="Consulta & PAP">Consulta + PAP y Colpo</SelectItem>
              <SelectItem value="Extracci√≥n & Colocaci√≥n de DIU">DIU / SIU / Implante</SelectItem>
              <SelectItem value="Terapia de Ginecolog√≠a Regenerativa">Terapia</SelectItem>
              <SelectItem value="Biopsia">Biopsia</SelectItem>
            </SelectContent>
          </Select>
          
          {/* Mostrar informaci√≥n sobre restricciones de servicios especiales */}
          {(editingRowData.serviceType === "Extracci√≥n & Colocaci√≥n de DIU" || 
            editingRowData.serviceType === "Terapia de Ginecolog√≠a Regenerativa") && (
            <div className={cn(
              "text-xs rounded p-1 text-center",
              compatibleWith40Min 
                ? "bg-orange-50 text-orange-700 border border-orange-100" 
                : "bg-red-50 text-red-700 border border-red-100"
            )}>
              {compatibleWith40Min
                ? "Servicio de 40 minutos - Horario compatible"
                : "¬°Atenci√≥n! Horario no compatible con servicio de 40 min"}
            </div>
          )}
        </div>
      );
    }
    
    // Para obra social
    if (field === 'obraSocial') {
      return (
        <Select 
          value={editingRowData.obraSocial}
          onValueChange={(value) => setEditingRowData({...editingRowData, obraSocial: value})}
        >
          <SelectTrigger className="h-8 text-xs">
            <SelectValue placeholder={editingRowData.obraSocial || "Seleccionar"} />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="Particular">Particular</SelectItem>
            <SelectItem value="IOMA">IOMA</SelectItem>
          </SelectContent>
        </Select>
      );
    }
    
    // Para otros campos, mostrar input de texto
    return (
      <Input
        value={
          field === 'patientName' ? editingRowData.patientName :
          field === 'email' ? editingRowData.email :
          field === 'phone' ? editingRowData.phone :
          field === 'notes' ? editingRowData.notes : ''
        }
        onChange={(e) => {
          // Actualizar el campo correspondiente
          if (field === 'patientName') {
            setEditingRowData({...editingRowData, patientName: e.target.value});
          } else if (field === 'email') {
            setEditingRowData({...editingRowData, email: e.target.value});
          } else if (field === 'phone') {
            setEditingRowData({...editingRowData, phone: e.target.value});
          } else if (field === 'notes') {
            setEditingRowData({...editingRowData, notes: e.target.value});
          }
        }}
        className="h-8 py-1 text-sm"
      />
    );
  };

  const handleSelectAppointment = (id: number, checked: boolean) => {
    if (checked) {
      setSelectedAppointments((prev) => [...prev, id]);
    } else {
      setSelectedAppointments((prev) => prev.filter((appId) => appId !== id));
    }
  };
  
  // Funciones para el manejo de drag and drop
  const handleDragStart = (event: DragStartEvent) => {
    const { active } = event;
    if (active.data.current?.type === 'appointment') {
      setActiveAppointmentDrag(active.data.current.appointment);
    }
  };

  const handleDragOver = (event: DragOverEvent) => {
    // Realizar acciones adicionales durante el arrastre si es necesario
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    
    if (!over) {
      setActiveAppointmentDrag(null);
      return;
    }
    
    // Si estamos arrastrando una cita
    if (active.data.current?.type === 'appointment' && over.data.current?.type === 'timeSlot') {
      const appointment = active.data.current.appointment as Appointment;
      const targetSlot = over.data.current as { day: Date, timeStr: string };
      
      // Crear la nueva fecha para la cita
      const [hours, minutes] = targetSlot.timeStr.split(':').map(Number);
      const newDate = new Date(targetSlot.day);
      newDate.setHours(hours, minutes, 0, 0);
      
      // Verificar si el nuevo slot est√° disponible (excluyendo la cita actual)
      const isAvailable = isTimeSlotAvailable(
        newDate,
        hours,
        minutes,
        appointments.filter(apt => apt.id !== appointment.id)
      );
      
      if (isAvailable) {
        // Actualizar la cita con la nueva fecha
        editMutation.mutate({
          id: appointment.id,
          data: {
            // Solo pasamos los campos necesarios para evitar problemas de tipo
            patientName: appointment.patientName,
            email: appointment.email,
            phone: appointment.phone,
            serviceType: appointment.serviceType || "Consulta",
            obraSocial: appointment.obraSocial || "Particular",
            isFirstTime: appointment.isFirstTime || false,
            notes: appointment.notes || "",
            appointmentTime: newDate,
            patientId: appointment.patientId,
          }
        });
        
        toast({
          title: "Turno movido",
          description: `Turno de ${appointment.patientName} movido a ${format(newDate, "d 'de' MMMM 'a las' HH:mm", { locale: es })}`,
        });
      } else {
        toast({
          title: "Horario no disponible",
          description: "No se pudo mover el turno al horario seleccionado",
          variant: "destructive"
        });
      }
    }
    
    setActiveAppointmentDrag(null);
  };

  const onSubmit = async (data: InsertAppointment) => {
    try {
      console.log("Form submission data:", data);

      if (!data.appointmentTime) {
        toast({
          title: "Error",
          description: "Por favor seleccione una fecha y hora para el turno",
          variant: "destructive"
        });
        return;
      }

      // Use the selected slot's time if available
      let appointmentDateTime: Date;
      
      if (selectedSlot && selectedSlot.fullDateTime) {
        // Usar el slot seleccionado guardado en el estado unificado (nueva forma)
        appointmentDateTime = new Date(selectedSlot.fullDateTime);
        console.log("Using selected slot datetime:", appointmentDateTime.toISOString());
        data.appointmentTime = appointmentDateTime;
      } else if (selectedTime && selectedDate) {
        // Usar nuestra funci√≥n utilitaria para construir la fecha
        const builtDate = buildAppointmentDate(selectedDate, selectedTime);
        if (builtDate) {
          appointmentDateTime = builtDate;
          data.appointmentTime = appointmentDateTime;
          console.log("Using buildAppointmentDate utility:", appointmentDateTime.toISOString());
        } else {
          // Fallback al tiempo del formulario
          appointmentDateTime = new Date(data.appointmentTime);
        }
      } else {
        // Fallback al tiempo del formulario
        appointmentDateTime = new Date(data.appointmentTime);
        console.log("Using form time as fallback:", appointmentDateTime.toISOString());
      }

      console.log("Processing appointment with datetime:", appointmentDateTime.toISOString());

      // Validate the time slot is available
      const isValidTimeSlot = isTimeSlotAvailable(
        appointmentDateTime,
        appointmentDateTime.getHours(),
        appointmentDateTime.getMinutes(),
        appointments
      );

      if (!isValidTimeSlot) {
        toast({
          title: "Error",
          description: "El horario seleccionado no est√° disponible",
          variant: "destructive"
        });
        return;
      }

      if (editingAppointment) {
        console.log("Editing appointment:", editingAppointment.id, data);
        await editMutation.mutateAsync({ 
          id: editingAppointment.id, 
          data 
        });
      } else {
        console.log("Creating new appointment:", data);
        await createAppointmentMutation.mutateAsync(data);
      }
    } catch (error) {
      console.log("Appointment submission error:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Error al procesar el turno",
        variant: "destructive"
      });
    }
  };

  const weekStart = startOfWeek(selectedWeek, { weekStartsOn: 1 });
  const weekEnd = endOfWeek(selectedWeek, { weekStartsOn: 1 });
  const allDaysInWeek = eachDayOfInterval({ start: weekStart, end: weekEnd });
  const daysInWeek = allDaysInWeek.filter((day) => {
    // Verificar primero si es un d√≠a de trabajo ocasional
    const dateStr = format(day, "yyyy-MM-dd");
    const isOccasionalWorkDay = scheduleConfig?.occasionalWorkDays?.includes(dateStr) || false;
    
    if (isOccasionalWorkDay) {
      console.log(`D√≠a ${format(day, "yyyy-MM-dd")} es d√≠a de trabajo ocasional en vista semanal`);
      return true;
    }
    
    // Si no es d√≠a ocasional, verificar si es un d√≠a de trabajo regular
    // Normalizar el nombre del d√≠a como se hace en el backend
    const dayName = format(day, "EEEE", { locale: es })
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    // Filtrar solo d√≠as laborables de scheduleConfig
    return scheduleConfig?.workDays.includes(dayName) || false;
  });

  const goToPreviousWeek = () => {
    setSelectedWeek(addWeeks(selectedWeek, -1));
  };

  const goToNextWeek = () => {
    setSelectedWeek(addWeeks(selectedWeek, 1));
  };

  const getAppointmentsForDay = (day: Date) => {
    return appointments.filter((apt) => 
      isSameDay(new Date(apt.appointmentTime), day) && 
      apt.status !== 'cancelled_by_professional' &&
      apt.status !== 'cancelled_by_patient'
    );
  };

  // Get time slots based on schedule configuration
  const timeSlots = scheduleConfig ? (() => {
    const [startHour, startMinute = 0] = scheduleConfig.startTime.split(":").map(Number);
    const [endHour, endMinute = 0] = scheduleConfig.endTime.split(":").map(Number);

    const startTotalMinutes = startHour * 60 + startMinute;
    const endTotalMinutes = endHour * 60 + endMinute;

    const slots: { hour: number; minute: number }[] = [];
    // Crear slots cada 20 minutos (9:00, 9:20, 9:40, 10:00, etc.)
    for (let minutes = startTotalMinutes; minutes < endTotalMinutes; minutes += 20) {
        const hour = Math.floor(minutes / 60);
        const minute = minutes % 60;
        // Solo incluir slots que son m√∫ltiplos de 20 minutos
        slots.push({ hour, minute });
    }

    return slots;
  })() : Array.from({ length: 9 }, (_, i) => ({ hour: i + 9, minute: 0 })); // Default if no config

  const getAvailableTimeSlotsForDay = (day: Date) => {
    // Usar nuestra nueva funci√≥n centralizada
    return getAvailableTimeSlotsForDate(day, appointments, editingAppointment?.id)
      .map(timeStr => {
        const [hoursStr, minutesStr] = timeStr.split(':');
        return {
          hour: parseInt(hoursStr, 10),
          minute: parseInt(minutesStr, 10)
        };
      });
  };

  useEffect(() => {
    if (selectedDate && selectedDate instanceof Date && !isNaN(selectedDate.getTime())) {
      const availableSlots = getAvailableTimeSlots(selectedDate);
      console.log("Available time slots for selected date:", availableSlots);

      // Set the full date and time in the form when date is selected
      if (availableSlots.length > 0) {
        const firstAvailableSlot = availableSlots[0];
        const formattedTime = `${firstAvailableSlot.hour}:${firstAvailableSlot.minute === 0 ? '00' : firstAvailableSlot.minute}`;
        handleSlotSelect(formattedTime);
      } else {
        // Clear the time selection if no slots are available
        setSelectedTime(null);
      }
    }
  }, [selectedDate, scheduleConfig]);


  const appointmentsPerPage = 5;
  const startOfNextWeek = addWeeks(
    startOfWeek(new Date(), { weekStartsOn: 1 }),
    1,
  );
  const endOfNextWeek = endOfWeek(startOfNextWeek, { weekStartsOn: 1 });

  const upcomingAppointments = appointments
    .filter((apt) => {
      const aptDate = new Date(apt.appointmentTime);
      // Excluir citas canceladas y verificar que est√©n en el rango de tiempo adecuado
      return (
        apt.status !== 'cancelled_by_patient' &&
        apt.status !== 'cancelled_by_professional' &&
        isAfter(aptDate, new Date()) &&
        isWithinInterval(aptDate, {
          start: new Date(),
          end: endOfNextWeek,
        })
      );
    })
    .sort(
      (a, b) =>
        new Date(a.appointmentTime).getTime() -
        new Date(b.appointmentTime).getTime(),
    )
    .slice(
      upcomingAppointmentsPage * appointmentsPerPage,
      (upcomingAppointmentsPage + 1) * appointmentsPerPage,
    );

  const totalUpcomingAppointments = appointments.filter((apt) => {
    const aptDate = new Date(apt.appointmentTime);
    return (
      apt.status !== 'cancelled_by_patient' &&
      apt.status !== 'cancelled_by_professional' &&
      isAfter(aptDate, new Date()) &&
      isWithinInterval(aptDate, {
        start: new Date(),
        end: endOfNextWeek,
      })
    );
  }).length;

  const totalPages = Math.max(
    1,
    Math.ceil(totalUpcomingAppointments / appointmentsPerPage),
  );

  const obraSocialOptions = [
    { value: "all", label: "Todas las obras sociales" },
    { value: "Particular", label: "Particular" },
    { value: "IOMA", label: "IOMA" },
  ];

  // Log para verificaci√≥n de datos iniciales de citas
  console.log("Total de citas recibidas del servidor:", appointments.length);
  if (appointments.length > 0) {
    console.log("Primera cita en la lista:", appointments[0]);
  }

  const filteredAppointments = appointments.filter((appointment) => {
    // Excluir citas canceladas 
    const notCancelled = 
      appointment.status !== 'cancelled_by_patient' && 
      appointment.status !== 'cancelled_by_professional';
    
    // Filtro de b√∫squeda (nombre o email)
    const searchLower = searchQuery.toLowerCase();
    const matchesSearch =
      appointment.patientName.toLowerCase().includes(searchLower) ||
      (appointment.email ? appointment.email.toLowerCase().includes(searchLower) : false);

    // Filtro de obra social (mejorado para manejar valores nulos/undefined)
    const matchesObraSocial =
      obraSocialFilter === "all" || 
      (obraSocialFilter === "Particular" && (!appointment.obraSocial || appointment.obraSocial === "Particular")) ||
      (appointment.obraSocial === obraSocialFilter);

    // Filtro de rango de fechas
    const appointmentDate = new Date(appointment.appointmentTime);
    const matchesDateRange =
      (!dateFilter.from ||
        isAfter(appointmentDate, startOfDay(dateFilter.from))) &&
      (!dateFilter.to || isBefore(appointmentDate, endOfDay(dateFilter.to)));

    // Detalle de por qu√© no pasa cada filtro
    if (!matchesSearch || !matchesObraSocial || !matchesDateRange || !notCancelled) {
      console.log(`Cita ${appointment.id} filtrada:`, {
        status: appointment.status,
        notCancelled,
        matchesSearch,
        matchesObraSocial,
        matchesDateRange,
        searchQuery: searchQuery,
        obraSocialFilter: obraSocialFilter,
        dateFilter: {
          from: dateFilter.from ? dateFilter.from.toISOString() : null,
          to: dateFilter.to ? dateFilter.to.toISOString() : null
        },
        appointmentDate: appointmentDate.toISOString()
      });
    }

    // Debe cumplir todos los filtros
    return notCancelled && matchesSearch && matchesObraSocial && matchesDateRange;
  });

  const totalFilteredPages = Math.max(
    1,
    Math.ceil(filteredAppointments.length / appointmentsPerPage)
  );

  const getWorkingDaysInMonth = (date: Date) => {
    if (!scheduleConfig) return [];

    const start = startOfMonth(date);
    const end = endOfMonth(date);
    const allDays = eachDayOfInterval({ start, end });

    // Log para depuraci√≥n
    console.log("Configuraci√≥n de d√≠as laborables:", scheduleConfig.workDays);
    console.log("D√≠as ocasionales configurados:", scheduleConfig.occasionalWorkDays);
    
    // Obtener los d√≠as de la semana en espa√±ol para cada d√≠a y filtrar
    const workingDays = allDays.filter((day) => {
      // Verificar si es un d√≠a de trabajo ocasional
      const dateStr = format(day, "yyyy-MM-dd");
      const isOccasionalWorkDay = scheduleConfig.occasionalWorkDays?.includes(dateStr) || false;
      
      if (isOccasionalWorkDay) {
        console.log(`D√≠a ${format(day, "yyyy-MM-dd")} es d√≠a de trabajo ocasional`);
        return true;
      }
      
      // Si no es d√≠a ocasional, verificar si es un d√≠a de trabajo regular
      // Obtener el nombre del d√≠a normalizado como se hace en el backend
      const dayName = format(day, "EEEE", { locale: es }).toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      // Verificar si este d√≠a est√° en la lista de d√≠as laborables
      const isDayWorking = scheduleConfig.workDays.includes(dayName);
      // Log detallado para depuraci√≥n
      console.log(`Comprobando: ${format(day, "yyyy-MM-dd")} (${dayName}), incluido: ${isDayWorking}, workDays: ${scheduleConfig.workDays}`);
      
      // Log para depuraci√≥n: Verificar cada d√≠a y si es laborable
      if (isDayWorking) {
        console.log(`D√≠a ${format(day, "yyyy-MM-dd")} (${dayName}) es laborable`);
      }
      
      return isDayWorking;
    });
    
    // Log para depuraci√≥n: Total de d√≠as laborables encontrados
    console.log(`Total de d√≠as laborables en ${format(date, "MMMM yyyy", { locale: es })}: ${workingDays.length}`);
    
    // Si no hay d√≠as laborables y es el mes actual, agregar al menos el d√≠a de hoy si es laborable
    if (workingDays.length === 0 && isSameMonth(date, new Date())) {
      const today = new Date();
      
      // Verificar si hoy es un d√≠a de trabajo ocasional
      const todayStr = format(today, "yyyy-MM-dd");
      const isTodayOccasional = scheduleConfig.occasionalWorkDays?.includes(todayStr) || false;
      
      if (isTodayOccasional) {
        console.log(`Agregando d√≠a actual (${todayStr}) como d√≠a laborable ocasional`);
        return [today];
      }
      
      // Normalizar el nombre del d√≠a como se hace en el backend
      const todayName = format(today, "EEEE", { locale: es })
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
      
      if (scheduleConfig.workDays.includes(todayName)) {
        console.log(`Agregando d√≠a actual (${format(today, "yyyy-MM-dd")}) como d√≠a laborable por defecto`);
        return [today];
      }
    }
    
    return workingDays;
  };

  // Log para verificar qu√© ocurre antes del ordenamiento
  console.log("Antes de ordenar y paginar - filteredAppointments:", filteredAppointments);
  
  // Verificaci√≥n de datos antes de ordenar
  console.log("viewMode actual:", viewMode);
  console.log("Estado de los filtros:", {
    searchQuery,
    obraSocialFilter,
    dateFilter: {
      from: dateFilter.from?.toISOString() || 'no establecido',
      to: dateFilter.to?.toISOString() || 'no establecido'
    }
  });
  
  const sortedAppointments = [...filteredAppointments]
    .sort((a, b) => {
      switch (sortOption) {
        case "date-desc":
          // 'm√°s reciente primero' - Ordenar por fecha/hora de forma descendente
          const timeA = new Date(a.appointmentTime).getTime();
          const timeB = new Date(b.appointmentTime).getTime();
          return timeB - timeA; // M√°s reciente primero
        case "date-asc":
          // 'm√°s antigua primero' - Ordenar por fecha/hora de forma ascendente
          const dateA = new Date(a.appointmentTime).getTime();
          const dateB = new Date(b.appointmentTime).getTime();
          return dateA - dateB; // M√°s antigua primero
        case "name-asc":
          return a.patientName.localeCompare(b.patientName);
        case "name-desc":
          return b.patientName.localeCompare(a.patientName);
        default:
          return 0;
      }
    })
    .slice(
      appointmentsPage * appointmentsPerPage,
      (appointmentsPage + 1) * appointmentsPerPage
    );
    
  // Log despu√©s del ordenamiento y paginaci√≥n
  console.log("Despu√©s de ordenar y paginar - sortedAppointments:", sortedAppointments);
    
  // Log para depurar el problema de las citas en modo Lista
  useEffect(() => {
    if (viewMode === "list") {
      console.log("Vista de Lista activada - Verificaci√≥n completa:");
      console.log("Citas totales:", appointments.length);
      console.log("Citas filtradas:", filteredAppointments.length);
      console.log("Citas mostradas despu√©s de ordenar y paginar:", sortedAppointments.length);
      console.log("Detalles de las citas a mostrar:", sortedAppointments);
      console.log("P√°gina actual:", appointmentsPage);
      console.log("Citas por p√°gina:", appointmentsPerPage);
    }
  }, [viewMode, appointments.length, filteredAppointments.length, sortedAppointments, appointmentsPage, appointmentsPerPage]);

  useEffect(() => {
    // Get all working days from the month regardless of availability
    const workingDays = getWorkingDaysInMonth(calendarMonth);

    // Set all working days as available dates without filtering by time slots
    setAvailableDates(workingDays);
    
    // Para prop√≥sitos de depuraci√≥n
    console.log("D√≠as laborables calculados:", workingDays.length);
    if (workingDays.length === 0 && scheduleConfig) {
      console.log("D√≠as laborables configurados:", scheduleConfig.workDays);
      console.log("Mes actual:", format(calendarMonth, "MMMM yyyy", { locale: es }));
      
      // Si no hay d√≠as disponibles, forzar al menos el d√≠a actual si es laborable
      const today = new Date();
      // Normalizar el nombre del d√≠a como se hace en el backend
      const dayName = format(today, "EEEE", { locale: es })
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
      if (scheduleConfig.workDays.includes(dayName)) {
        console.log("Agregando d√≠a actual como disponible:", format(today, "PPP", { locale: es }));
        setAvailableDates([today]);
      }
    }
  }, [calendarMonth, scheduleConfig]);

  // Get all available time slots for a specific date, including 30-minute intervals
  const getAvailableTimeSlots = (date: Date) => {
    // Usar nuestra funci√≥n centralizada y convertir los resultados al formato esperado
    const availableTimeStrings = getAvailableTimeSlotsForDate(date, appointments, editingAppointment?.id);
    
    // Convertir strings de hora a objetos de slot
    const slots = availableTimeStrings.map(timeStr => {
      const [hoursStr, minutesStr] = timeStr.split(':');
      return {
        hour: parseInt(hoursStr, 10),
        minute: parseInt(minutesStr, 10)
      };
    });
    
    console.log(`Available slots for ${date.toDateString()}:`, slots.map(s => `${s.hour}:${s.minute}`));
    return slots;
  };

  // Este efecto se ejecuta cuando cambia la fecha seleccionada
  // pero solo debe calcular horarios disponibles, no seleccionar uno autom√°ticamente
  useEffect(() => {
    if (selectedDate && selectedDate instanceof Date && !isNaN(selectedDate.getTime())) {
      const availableSlots = getAvailableTimeSlots(selectedDate);
      console.log("Available time slots for selected date:", availableSlots);
      
      // Ya no seleccionamos autom√°ticamente ning√∫n slot aqu√≠ para evitar ciclos
      // El usuario debe seleccionar expl√≠citamente un horario
    }
  }, [selectedDate, scheduleConfig]);
  
  // Efecto separado para manejar la edici√≥n de citas 
  // que se ejecuta SOLO cuando cambia editingAppointment, no cuando cambia selectedDate
  useEffect(() => {
    if (editingAppointment) {
      // Este c√≥digo se ejecuta solo cuando editingAppointment cambia, no en cada cambio de selectedDate
      console.log("Setting up appointment for editing");
      
      // No llamamos a handleSlotSelect aqu√≠ porque ya se establece 
      // el tiempo correctamente en el otro useEffect que maneja editingAppointment
    }
  }, [editingAppointment]);

  // Funci√≥n utilitaria para construir una fecha con hora espec√≠fica
  const buildAppointmentDate = (date: Date, timeStr: string): Date | null => {
    // Validate time format
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timeRegex.test(timeStr)) {
      console.log("Invalid time format:", timeStr);
      return null;
    }
    
    // Parse time string
    const [hoursStr, minutesStr] = timeStr.split(":");
    const hours = parseInt(hoursStr, 10);
    const minutes = parseInt(minutesStr, 10) || 0;
    
    // Crear una nueva fecha para evitar mutaciones de objetos originales
    const newDate = new Date(date);
    // Normalizar siempre los segundos y milisegundos a cero
    newDate.setHours(hours, minutes, 0, 0);
    
    return newDate;
  };
  
  // Normalizar formato de hora a formato est√°ndar con ceros iniciales
  const formatTimeString = (timeStr: string): string => {
    const [hoursStr, minutesStr] = timeStr.split(":");
    const hours = parseInt(hoursStr, 10);
    const minutes = parseInt(minutesStr, 10) || 0;
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  };
  
  // Funci√≥n para preparar datos de slot, sin efectos secundarios
  const prepareSlotData = (timeStr: string, dayParam?: Date): {
    slotData: SelectedSlot | null,
    formattedTime: string,
    dateTime: Date | null
  } => {
    console.log("Preparing slot data:", timeStr, "on day:", dayParam ? dayParam.toISOString() : 'undefined');
    
    // Normalizar formato de hora
    const formattedTimeStr = formatTimeString(timeStr);
    
    // Determinar la fecha base a usar
    const baseDate = dayParam ? new Date(dayParam) : 
                    (selectedDate ? new Date(selectedDate) : 
                     (selectedSlot?.date ? new Date(selectedSlot.date) : new Date()));
    
    console.log("Base date for appointment:", baseDate.toISOString());
    
    // Construir la fecha del turno
    const appointmentDateTime = buildAppointmentDate(baseDate, formattedTimeStr);
    
    // Si hay error en la construcci√≥n de la fecha, salir
    if (!appointmentDateTime) {
      return { slotData: null, formattedTime: formattedTimeStr, dateTime: null };
    }
    
    console.log("Final datetime for slot:", appointmentDateTime.toISOString());
    
    // Extraer horas y minutos
    const hours = appointmentDateTime.getHours();
    const minutes = appointmentDateTime.getMinutes();
    
    // Crear objeto de slot seleccionado
    const newSlotData: SelectedSlot = {
      date: new Date(baseDate),
      time: formattedTimeStr,
      hour: hours,
      minute: minutes,
      fullDateTime: new Date(appointmentDateTime)
    };
    
    return { 
      slotData: newSlotData, 
      formattedTime: formattedTimeStr, 
      dateTime: appointmentDateTime
    };
  };
  
  // Funci√≥n para actualizar el formulario con una fecha espec√≠fica
  const updateFormDateTime = (dateTime: Date, delay = 0) => {
    // Limpiar cualquier timeout anterior
    if (formUpdateTimeout.current) {
      clearTimeout(formUpdateTimeout.current);
    }
    
    // Crear una copia exacta de la fecha para evitar mutaciones
    const dateToSet = new Date(dateTime.getTime());
    
    // Hacer la actualizaci√≥n despu√©s del retraso especificado
    formUpdateTimeout.current = setTimeout(() => {
      console.log("Setting form time to:", dateToSet.toISOString());
      
      form.setValue("appointmentTime", dateToSet, {
        shouldValidate: true,
        shouldDirty: true,
        shouldTouch: true
      });
      
      // Verificaci√≥n
      const formValue = form.getValues("appointmentTime");
      if (formValue instanceof Date) {
        console.log("Form time after setValue:", formValue.toISOString());
      } else {
        console.warn("Form value is not a date:", formValue);
      }
    }, delay);
  };
  
  // Funci√≥n para resetear el formulario con nuevos valores
  const resetFormWithTime = (dateTime: Date) => {
    // Crear una copia de la fecha
    const formDate = new Date(dateTime.getTime());
    
    // Resetear el formulario completo
    form.reset({
      patientName: "",
      email: "",
      phone: "",
      serviceType: "Consulta",
      obraSocial: "Particular",
      isFirstTime: false,
      notes: "",
      appointmentTime: formDate
    });
    
    // Forzar actualizaci√≥n del valor despu√©s del reset
    updateFormDateTime(formDate, 50);
  };
  
  // Funci√≥n principal para manejar la selecci√≥n de slots
  const handleSlotSelect = (slotStr: string, shouldOpenForm = false, day?: Date) => {
    // Preparar los datos pero sin actualizar estados
    const { slotData, formattedTime, dateTime } = prepareSlotData(slotStr, day);
    
    // Si hubo un error al preparar los datos, salimos
    if (!slotData || !dateTime) {
      console.log("Error preparing slot data");
      return;
    }
    
    console.log("Handling slot selection with data:", JSON.stringify(slotData));
    
    // Actualizar estados solo cuando sea necesario para evitar ciclos
    const shouldUpdateState = day || !selectedDate || !selectedSlot;
    
    if (shouldUpdateState) {
      console.log("Updating application state");
      
      // Actualizar referencia para compatibilidad
      selectedSlotRef.current = {
        date: new Date(slotData.date),
        time: formattedTime,
        hour: slotData.hour,
        minute: slotData.minute
      };
      
      // Actualizar todos los estados juntos (React 18 los agrupar√°)
      setSelectedSlot(slotData);
      setSelectedDate(new Date(slotData.date));
      setSelectedTime(formattedTime);
    } else {
      console.log("Skipping state update to prevent cycles");
    }
    
    // Manejar edici√≥n de cita existente
    if (editingAppointment) {
      updateFormDateTime(dateTime, 10);
      return;
    }
    
    // Manejar creaci√≥n de nueva cita 
    if (shouldOpenForm) {
      // NUEVO ENFOQUE: En lugar de abrir el modal, mostrar el NewQuickAppointmentForm en el slot
      console.log("Estableciendo quickFormSlot con:", formattedTime, "para la fecha", new Date(slotData.date));
      setQuickFormSlot({
        timeStr: formattedTime,
        date: new Date(slotData.date)
      });
      console.log("Estado quickFormSlot actualizado");
      
      // Antiguo enfoque con el modal (ahora desactivado)
      // Marcar que se est√° abriendo desde la selecci√≥n de slot
      // openingFromSlotRef.current = true;
      // Preparar el formulario antes de mostrarlo
      // resetFormWithTime(dateTime);
      // Mostrar di√°logo de nuevo turno
      // setShowNewAppointment(true);
    }
  };

  // Validaci√≥n centralizada de disponibilidad de horarios
  const isSlotAvailable = (date: Date, timeStr: string, appointments: Appointment[], editingId?: number): boolean => {
    if (!scheduleConfig) return false;
    
    // Construir la fecha del slot a verificar
    const appointmentDateTime = buildAppointmentDate(date, timeStr);
    if (!appointmentDateTime) return false;
    
    // Extraer hora y minutos para c√°lculos
    const hour = appointmentDateTime.getHours();
    const minute = appointmentDateTime.getMinutes();
    const slotTimeInMinutes = hour * 60 + minute;
    
    // Verificar si est√° dentro del horario laboral
    const [startHour, startMinute] = scheduleConfig.startTime.split(':').map(Number);
    const [endHour, endMinute] = scheduleConfig.endTime.split(':').map(Number);
    const startTimeInMinutes = startHour * 60 + startMinute;
    const endTimeInMinutes = endHour * 60 + endMinute;
    
    if (slotTimeInMinutes < startTimeInMinutes || slotTimeInMinutes >= endTimeInMinutes) {
      return false;
    }
    
    // Verificar si no hay conflictos con otros turnos
    return !appointments.some((apt) => {
      // Si estamos editando este turno, considerarlo como disponible
      if (editingId && apt.id === editingId) {
        return false;
      }
      
      // Ignorar citas canceladas
      if (apt.status === 'cancelled_by_patient' || apt.status === 'cancelled_by_professional') {
        return false;
      }
      
      // Normalizar la hora del turno existente para comparaci√≥n
      const aptTime = new Date(apt.appointmentTime);
      aptTime.setSeconds(0, 0); // Normalizar segundos
      
      // Solo verificar citas del mismo d√≠a
      if (!isSameDay(aptTime, appointmentDateTime)) {
        return false;
      }
      
      const aptHour = aptTime.getHours();
      const aptMinute = aptTime.getMinutes();
      const aptTimeInMinutes = aptHour * 60 + aptMinute;
      
      // Determinar la duraci√≥n del servicio existente
      const existingServiceDuration = isFortyMinService(apt.serviceType || "") ? 40 : 20; 
      
      // Determinar la duraci√≥n del nuevo servicio (por defecto 20 min)
      const newServiceDuration = 20; // Para verificar disponibilidad siempre usamos 20 min
      
      // Calcular los tiempos de finalizaci√≥n
      const existingServiceEndTime = aptTimeInMinutes + existingServiceDuration;
      const newServiceEndTime = slotTimeInMinutes + newServiceDuration;
      
      // Permitir expl√≠citamente citas "back-to-back" (una comienza cuando termina otra)
      // Escenarios permitidos:
      // 1. El nuevo servicio comienza exactamente cuando termina el existente
      const newServiceStartsWhenExistingEnds = slotTimeInMinutes === existingServiceEndTime;
      
      // 2. El servicio existente comienza exactamente cuando termina el nuevo
      const existingServiceStartsWhenNewEnds = aptTimeInMinutes === newServiceEndTime;
      
      // Verificar si hay superposici√≥n real y no es un caso "back-to-back"
      const hasOverlap = 
        ((slotTimeInMinutes >= aptTimeInMinutes && slotTimeInMinutes < existingServiceEndTime) || 
         (aptTimeInMinutes >= slotTimeInMinutes && aptTimeInMinutes < newServiceEndTime)) && 
        !newServiceStartsWhenExistingEnds && 
        !existingServiceStartsWhenNewEnds;
      
      // Si hay superposici√≥n, el slot no est√° disponible
      return hasOverlap;
    });
  };
  
  // Funci√≥n para obtener slots disponibles para un d√≠a espec√≠fico
  const getAvailableTimeSlotsForDate = (
    date: Date, 
    appointments: Appointment[], 
    editingId?: number
  ): string[] => {
    if (!scheduleConfig) return [];
    
    const [startHour, startMinute = 0] = scheduleConfig.startTime.split(':').map(Number);
    const [endHour, endMinute = 0] = scheduleConfig.endTime.split(':').map(Number);
    
    const startTotal = startHour * 60 + startMinute;
    const endTotal = endHour * 60 + endMinute;
    
    const availableSlots: string[] = [];
    
    // Generar slots cada 20 minutos
    const intervalMinutes = 20;
    
    for (let minutes = startTotal; minutes < endTotal; minutes += intervalMinutes) {
      const hour = Math.floor(minutes / 60);
      const minute = minutes % 60;
      const slotStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
      
      if (isSlotAvailable(date, slotStr, appointments, editingId)) {
        availableSlots.push(slotStr);
      }
    }
    
    return availableSlots;
  };
  
  // Compatibilidad con la funci√≥n original para no romper las referencias existentes
  const isTimeSlotAvailable = (day: Date, hour: number, minute: number, appointments: Appointment[], editingId?: number): boolean => {
    const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    return isSlotAvailable(day, timeStr, appointments, editingAppointment?.id);
  };

  // Calendar rendering components
  // A√±adir funci√≥n auxiliar para filtrar citas para un d√≠a y hora espec√≠ficos
  const getAppointmentsForDayAndTime = (day: Date, hour: number, minute: number) => {
    return appointments.filter(appointment => {
      // Ignorar citas canceladas
      if (appointment.status === 'cancelled_by_patient' || appointment.status === 'cancelled_by_professional') {
        return false;
      }
      
      const aptDate = new Date(appointment.appointmentTime);
      return (
        isSameDay(aptDate, day) && 
        aptDate.getHours() === hour && 
        aptDate.getMinutes() === minute
      );
    });
  };
  
  // Nueva funci√≥n para verificar si hay una cita de 40 minutos que ocupa parcialmente un slot
  const getOverlappingFortyMinAppointments = (day: Date, hour: number, minute: number) => {
    return appointments.filter(appointment => {
      // Ignorar citas canceladas
      if (appointment.status === 'cancelled_by_patient' || appointment.status === 'cancelled_by_professional') {
        return false;
      }

      // Solo nos interesan las citas de 40 minutos
      if (!isFortyMinService(appointment.serviceType || "")) return false;
      
      const aptDate = new Date(appointment.appointmentTime);
      
      // No nos interesa si no es el mismo d√≠a
      if (!isSameDay(aptDate, day)) return false;
      
      const aptHour = aptDate.getHours();
      const aptMinute = aptDate.getMinutes();
      
      // Convertir ambos horarios a minutos totales para facilitar la comparaci√≥n
      const slotTimeInMinutes = hour * 60 + minute;
      const aptTimeInMinutes = aptHour * 60 + aptMinute;
      
      // Una cita de 40 minutos ocupa tres bloques de 20 minutos (9:00, 9:20, 9:40)
      // Por ejemplo, una cita a las 9:00 ocupa de 9:00 a 9:40, 
      // por lo que bloquea los slots de 9:00, 9:20 y 9:40
      
      // Verificar si el slot actual est√° dentro del rango de la cita de 40 minutos
      // El slot est√° ocupado si est√° a 0, 20 o 40 minutos despu√©s del inicio de la cita
      if (slotTimeInMinutes === aptTimeInMinutes || 
          slotTimeInMinutes === aptTimeInMinutes + 20 || 
          slotTimeInMinutes === aptTimeInMinutes + 40) {
        console.log(`Slot ${hour}:${minute} ocupado por cita de 40 min a las ${aptHour}:${aptMinute}`);
        return true;
      }
      
      return false;
    });
  };

  const renderCalendarGrid = () => {
    if (!scheduleConfig) return null;

    return (
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragStart={handleDragStart}
        onDragOver={handleDragOver}
        onDragEnd={handleDragEnd}
      >
        <div className="grid grid-cols-[auto,1fr] gap-4">
          <div className="space-y-4">
            {timeSlots.map((slot) => (
              <div 
                key={`header-${slot.hour}-${slot.minute}`}
                className="h-24 flex items-center justify-end pr-4 text-sm font-medium"
              >
                {`${slot.hour.toString().padStart(2, '0')}:${slot.minute.toString().padStart(2, '0')}`}
              </div>
            ))}
          </div>
          <div className="grid grid-cols-7 gap-px bg-primary/10">
            {daysInWeek.map((day) => (
              <div key={day.toISOString()}>
                <div className="bg-background p-2 text-center">
                  <div className="text-sm font-medium">
                    {format(day, "EEEE", { locale: es })}
                  </div>
                  <div className="text-xs text-muted-foreground">
                    {format(day, "d MMM", { locale: es })}
                  </div>
                </div>
                <div className="divide-y divide-primary/10">
                  {timeSlots.map((slot) => {
                    const formattedTime = `${slot.hour.toString().padStart(2, '0')}:${slot.minute.toString().padStart(2, '0')}`;
                    const appointmentsForSlot = getAppointmentsForDayAndTime(day, slot.hour, slot.minute);
                    
                    // Excluimos la cita actualmente en arrastre, si existe
                    const filteredAppointments = activeAppointmentDrag 
                      ? appointmentsForSlot.filter(apt => apt.id !== activeAppointmentDrag.id)
                      : appointmentsForSlot;
                    
                    // Calcular disponibilidad considerando la cita en arrastre
                    const isAvailable = isTimeSlotAvailable(
                      day, 
                      slot.hour, 
                      slot.minute, 
                      activeAppointmentDrag 
                        ? appointments.filter(apt => apt.id !== activeAppointmentDrag.id)
                        : appointments
                    );
                    
                    const isCurrentSlot = quickFormSlot?.timeStr === formattedTime && 
                                         isSameDay(quickFormSlot.date, day);
                    
                    // Verificar si hay citas de 40 minutos que ocupen parcialmente este slot
                    const overlappingFortyMinAppts = getOverlappingFortyMinAppointments(day, slot.hour, slot.minute);
                    
                    // Determinar si este slot est√° parcialmente ocupado
                    const isPartiallyOccupied = overlappingFortyMinAppts.length > 0;
                    
                    // Si hay citas en este slot, mostrarlas como draggables
                    return (
                      <div 
                        key={`${day.toISOString()}-${slot.hour}-${slot.minute}`}
                        className={cn(
                          "h-24 relative border-b border-primary/10 last:border-b-0",
                          isAvailable 
                            ? isPartiallyOccupied 
                              ? "bg-yellow-50" // Slot parcialmente ocupado
                              : "bg-green-50" // Slot totalmente disponible
                            : (filteredAppointments.length > 0 ? "bg-primary/5" : "bg-red-50") // Slot ocupado o no disponible
                        )}
                      >
                        {isCurrentSlot ? (
                          // Mostrar el formulario r√°pido en este slot
                          <NewQuickAppointmentForm 
                            date={new Date(day)}
                            timeStr={formattedTime}
                            onSubmit={(data: InsertAppointment) => {
                              createAppointmentMutation.mutate(data);
                              setQuickFormSlot(null); // Cerrar formulario despu√©s de enviar
                            }}
                            onCancel={() => setQuickFormSlot(null)}
                            isPending={createAppointmentMutation.isPending}
                          />
                        ) : (
                          <DroppableTimeSlot
                            day={day}
                            timeStr={formattedTime}
                            isAvailable={isAvailable}
                            // Para mostrar las citas de 40 minutos visualmente diferentes
                            isForty={filteredAppointments.length > 0 && filteredAppointments.some(apt => 
                              isFortyMinService(apt.serviceType || "")
                            )}
                            // Pasar informaci√≥n sobre ocupaci√≥n parcial
                            isPartiallyOccupied={isPartiallyOccupied}
                            previousAppointment={isPartiallyOccupied && overlappingFortyMinAppts.length > 0 
                              ? overlappingFortyMinAppts[0] 
                              : undefined}
                            serviceType={filteredAppointments.length > 0 && filteredAppointments.some(apt => 
                              isFortyMinService(apt.serviceType || "")
                            ) ? (filteredAppointments[0].serviceType || undefined) : undefined}
                            onClick={() => {
                              // Si hay citas, mostrar detalles, de lo contrario abrir el formulario
                              if (filteredAppointments.length > 0) {
                                setSelectedAppointment(filteredAppointments[0]);
                              } else if (isAvailable) {
                                handleSlotSelect(formattedTime, true, day);
                              }
                            }}
                          >
                            {filteredAppointments.length > 0 ? (
                              <div className="p-1 h-full">
                                {filteredAppointments.map((appointment) => (
                                  <CalendarAppointment
                                    key={`apt-${appointment.id}`}
                                    appointment={appointment}
                                    onCancel={setCancelConfirmId}
                                    onNoShow={(id) => noShowMutation.mutate(id)}
                                    onAttended={(id) => attendedMutation.mutate(id)}
                                    onEdit={(appointment) => {
                                      // Obtener la hora y fecha de la cita
                                      const aptDate = new Date(appointment.appointmentTime);
                                      const hour = aptDate.getHours();
                                      const minute = aptDate.getMinutes();
                                      const timeStr = `${hour.toString().padStart(2, '0')}:${minute === 0 ? '00' : minute}`;
                                      
                                      // Establecer el quickFormSlot para usar el formulario r√°pido
                                      setQuickFormSlot({
                                        timeStr: timeStr,
                                        date: aptDate,
                                        appointment: appointment
                                      });
                                    }}
                                    onDelete={(id) => setDeleteConfirmId(id)}
                                    onDetails={(appointment) => setSelectedAppointment(appointment)}
                                  />
                                ))}
                              </div>
                            ) : null}
                          </DroppableTimeSlot>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            ))}
          </div>
        </div>
      </DndContext>
    );
  };

  const disabledDates = useCallback((date: Date): boolean => {
    if (!scheduleConfig) return true;

    // Formatear la fecha para verificar si es un d√≠a ocasional
    const dateStr = format(date, "yyyy-MM-dd");
    const isOccasionalWorkDay = scheduleConfig.occasionalWorkDays?.includes(dateStr) || false;
    
    // Si es un d√≠a de trabajo ocasional, siempre est√° disponible (si no es pasado y no est√° en vacaciones)
    if (isOccasionalWorkDay) {
      // Comprobar si est√° en periodo de vacaciones
      const isVacation = scheduleConfig.vacationPeriods?.some((period) =>
        isWithinInterval(date, {
          start: new Date(period.start),
          end: new Date(period.end),
        })
      ) ?? false;

      // Comprobar si es anterior a hoy
      const isPast = isBefore(date, startOfDay(new Date()));
      
      // Log para diagn√≥stico
      console.log(`Fecha: ${dateStr} - D√≠a ocasional: ${isOccasionalWorkDay}, es vacaciones: ${isVacation}, es pasado: ${isPast}`);
      
      return isVacation || isPast;
    }

    // Si no es d√≠a ocasional, aplicar las reglas normales
    // Normalizar el nombre del d√≠a como se hace en el backend
    const dayName = format(date, "EEEE", { locale: es })
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    
    // Comprobar si es d√≠a laboral usando la versi√≥n normalizada
    const isWorkDay = scheduleConfig.workDays.includes(dayName);
    
    // Comprobar si est√° en periodo de vacaciones
    const isVacation = scheduleConfig.vacationPeriods?.some((period) =>
      isWithinInterval(date, {
        start: new Date(period.start),
        end: new Date(period.end),
      })
    ) ?? false;

    // Comprobar si es anterior a hoy
    const isPast = isBefore(date, startOfDay(new Date()));
    
    // Log para diagn√≥stico
    console.log(`Fecha: ${format(date, 'yyyy-MM-dd')} (${dayName}), es d√≠a laboral: ${isWorkDay}, es vacaciones: ${isVacation}, es pasado: ${isPast}`);
    
    return !isWorkDay || isVacation || isPast;
  }, [scheduleConfig]);





  if (checkingAuth || loadingAppointments) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-background to-secondary/20">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-secondary/20 p-4 md:p-6">
      {/* Barra de navegaci√≥n superior */}
      
      <Card className="border-primary/10">
        <CardContent className="p-4 sm:p-6">
          <div className="flex flex-col sm:flex-row justify-between gap-4 sm:items-center mb-6">
            <div className="flex items-center gap-3">
              <div>
                <CardTitle className="text-xl sm:text-2xl font-bold text-primary">
                  Panel Administrativo
                </CardTitle>
                <CardDescription className="text-base sm:text-lg">
                  Dra. Jazm√≠n Monta√±√©s - Ginecolog√≠a y Obstetricia
                </CardDescription>
                <CardDescription className="text-xs sm:text-sm">
                  {format(currentTime, "EEEE, d 'de' MMMM 'de' yyyy', ' HH:mm 'hs'", {
                    locale: es,
                  })}
                </CardDescription>
              </div>
            </div>
            <div className="flex flex-wrap gap-2">
              <Button
                variant="outline"
                onClick={() => window.location.href = '/'}
                className="text-xs sm:text-sm border-primary/20 hover:bg-primary/5"
                size="sm"
              >
                <ArrowLeft className="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2" />
                Volver a Turnos
              </Button>
              <Button
                variant="outline"
                onClick={() => setShowScheduleSettings(true)}
                className="text-xs sm:text-sm border-primary/20 hover:bg-primary/5"
                size="sm"
              >
                <Settings className="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2" />
                Configuraci√≥n
              </Button>
              <Button
                variant="outline"
                onClick={() => sendDailySummaryMutation.mutate()}
                className="text-xs sm:text-sm border-primary/20 hover:bg-primary/5"
                size="sm"
                disabled={sendDailySummaryMutation.isPending}
              >
                <CalendarClock className="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2" />
                {sendDailySummaryMutation.isPending ? "Enviando..." : "Enviar Resumen"}
              </Button>
              <Button
                variant="outline"
                onClick={handleLogout}
                className="text-xs sm:text-sm border-primary/20 hover:bg-primary/5"
                size="sm"
              >
                <LogOut className="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2" />
                Cerrar sesi√≥n
              </Button>
            </div>
          </div>
          {/* Secci√≥n superior con estad√≠sticas y carrusel de pr√≥ximos turnos */}
          <div className="grid grid-cols-1 lg:grid-cols-5 gap-6 mb-6">
            {/* Panel de pr√≥ximos turnos */}
            <div className="lg:col-span-3">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-semibold flex items-center gap-2">
                  <CalendarIcon2 className="w-5 h-5 text-primary" />
                  Pr√≥ximos Turnos (Esta semana y la siguiente)
                </h3>
              </div>
              <AppointmentsCarousel
                appointments={upcomingAppointments}
                onEdit={setEditingAppointment}
                onDelete={setDeleteConfirmId}
                onCancel={setCancelConfirmId}
                onReminder={(id) => {
                  if (id !== undefined) {
                    reminderMutation.mutate(id);
                  }
                }}
                onViewHistory={setShowClinicalHistory}
              />
            </div>
            
            {/* Panel de estad√≠sticas */}
            <div className="lg:col-span-2">
              <StatisticsPreview />
            </div>
          </div>

          <div className="flex justify-end mb-4 gap-2">
            <div className="inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground">
              <Button
                variant={viewMode === "calendar" ? "default" : "ghost"}
                onClick={() => setViewMode("calendar")}
                className="rounded-sm px-3 text-sm font-medium"
              >
                Calendario
              </Button>
              <Button
                variant={viewMode === "list" ? "default" : "ghost"}
                onClick={() => setViewMode("list")}
                className="rounded-sm px-3 text-sm font-medium"
              >
                Lista
              </Button>
            </div>
          </div>

          {/* Log de modo de visualizaci√≥n */}
          {(() => { console.log("Renderizando en modo:", viewMode); return null; })()}
          {viewMode === "list" ? (
            // Para evitar problemas de sintaxis, usamos un Fragment expl√≠cito para envolver todo
            <>
              {/* Log de debug */}
              {(() => { console.log("Renderizando LA VISTA DE LISTA ahora"); return null; })()}
              <div className="mb-4 space-y-4">
                <div className="flex flex-col md:flex-row md:items-center gap-4">
                  <div className="relative w-full md:flex-1">
                    <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                    <Input
                      placeholder="Buscar por nombre o email..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className="pl-8 border-primary/20 w-full"
                    />
                  </div>

                  <div className="flex flex-wrap items-center gap-2">
                    <Popover>
                      <PopoverTrigger asChild>
                        <Button
                          variant="outline"
                          className={cn(
                            "justify-start text-left font-normal border-primary/20 text-xs sm:text-sm w-full sm:w-auto sm:max-w-[280px]",
                            !dateFilter.from && "text-muted-foreground",
                          )}
                        >
                          <CalendarIcon2 className="mr-2 h-4 w-4 flex-shrink-0" />
                          <span className="truncate">
                            {dateFilter.from ? (
                              dateFilter.to ? (
                                <>
                                  {format(dateFilter.from, "P", { locale: es })} -{" "}
                                  {format(dateFilter.to, "P", { locale: es })}
                                </>
                              ) : (
                                format(dateFilter.from, "P", { locale: es })
                              )
                            ) : (
                              "Seleccionar fechas"
                            )}
                          </span>
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          initialFocus
                          mode="range"
                          defaultMonth={dateFilter.from}
                          selected={{
                            from: dateFilter.from,
                            to: dateFilter.to,
                          }}
                          onSelect={(range) => {
                            setDateFilter({
                              from: range?.from,
                              to: range?.to,
                            });
                          }}
                          numberOfMonths={window.innerWidth < 768 ? 1 : 2}
                        />
                      </PopoverContent>
                    </Popover>
                    <Select value={sortOption} onValueChange={setSortOption}>
                      <SelectTrigger className="w-full sm:w-[200px] border-primary/20 text-xs sm:text-sm">
                        <ArrowUpDown className="mr-2 h-4 w-4 flex-shrink-0" />
                        <SelectValue placeholder="Ordenar por..." />
                      </SelectTrigger>
                      <SelectContent>
                        {sortOptions.map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <Select
                      value={obraSocialFilter}
                      onValueChange={setObraSocialFilter}
                    >
                      <SelectTrigger className="w-full sm:w-[200px] border-primary/20 text-xs sm:text-sm">
                        <Filter className="mr-2 h-4 w-4 flex-shrink-0" />
                        <SelectValue placeholder="Filtrar por obra social" />
                      </SelectTrigger>
                      <SelectContent>
                        {obraSocialOptions.map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    {selectedAppointments.length > 0 && (
                      <Button
                        variant="destructive"
                        onClick={() => setShowBulkDeleteConfirm(true)}
                        className="whitespace-nowrap text-xs sm:text-sm"
                        size="sm"
                      >
                        <Trash2 className="w-4 h-4 mr-2 flex-shrink-0" />
                        Eliminar ({selectedAppointments.length})
                      </Button>
                    )}
                  </div>
                </div>
              </div>
              {/* Vista para m√≥viles - solo visible en pantallas peque√±as */}
              <div className="block md:hidden mb-6">
                {sortedAppointments.map((appointment) => (
                  <Card key={appointment.id} className="mb-4 overflow-hidden border-primary/10">
                    <CardContent className="p-4">
                      <div className="flex justify-between items-start mb-2">
                        <div className="font-medium">
                          {format(new Date(appointment.appointmentTime), "PPpp", {
                            locale: es,
                          })}
                        </div>
                        <Checkbox
                          checked={selectedAppointments.includes(appointment.id)}
                          onCheckedChange={(checked) =>
                            handleSelectAppointment(
                              appointment.id,
                              checked as boolean,
                            )
                          }
                        />
                      </div>
                      
                      <div className="grid grid-cols-2 gap-y-2 mb-3 text-sm">
                        <div className="text-muted-foreground">Paciente:</div>
                        <div>{appointment.patientName}</div>
                        
                        <div className="text-muted-foreground">Servicio:</div>
                        <div>{appointment.serviceType || "Consulta"}</div>
                        
                        <div className="text-muted-foreground">Obra Social:</div>
                        <div>{appointment.obraSocial || "Particular"}</div>
                        
                        <div className="text-muted-foreground">Email:</div>
                        <div className="truncate">{appointment.email || "-"}</div>
                        
                        <div className="text-muted-foreground">Tel√©fono:</div>
                        <div>{appointment.phone || "-"}</div>
                      </div>
                      
                      <div className="flex flex-wrap gap-2 mt-3">
                        {appointment.patientId && (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => setShowClinicalHistory(appointment.patientId)}
                            className="border-primary/20 hover:bg-primary/5 text-xs"
                          >
                            <FileText className="h-3 w-3 mr-1" />
                            Historia
                          </Button>
                        )}
                        <Button
                          variant={inlineEditId === appointment.id ? "default" : "outline"}
                          size="sm"
                          onClick={() => {
                            if (inlineEditId === appointment.id) {
                              saveRowEdits();
                            } else {
                              handleInlineEdit(appointment.id);
                            }
                          }}
                          className={inlineEditId === appointment.id ? "text-xs" : "border-primary/20 hover:bg-primary/5 text-xs"}
                        >
                          {inlineEditId === appointment.id ? (
                            <>
                              <Check className="h-3 w-3 mr-1" />
                              Guardar
                            </>
                          ) : (
                            <>
                              <Edit className="h-3 w-3 mr-1" />
                              Editar
                            </>
                          )}
                        </Button>
                        {inlineEditId === appointment.id && (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={cancelRowEdit}
                            className="ml-1 border-destructive/20 hover:bg-destructive/5 text-xs"
                          >
                            <X className="h-3 w-3 mr-1" />
                            Cancelar
                          </Button>
                        )}
                        <Button
                          variant="default"
                          size="sm"
                          onClick={() => setCancelConfirmId(appointment.id)}
                          className="text-xs bg-amber-600 hover:bg-amber-700 text-white"
                          disabled={appointment.status === 'cancelled_by_patient' || appointment.status === 'cancelled_by_professional'}
                        >
                          <XCircle className="h-3 w-3 mr-1" />
                          Cancelar
                        </Button>
                        <Button
                          variant="destructive"
                          size="sm"
                          onClick={() => setDeleteConfirmId(appointment.id)}
                          className="text-xs"
                        >
                          <Trash2 className="h-3 w-3 mr-1" />
                          Eliminar
                        </Button>
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
              
              {/* Vista para escritorio - visible en todos los dispositivos */}
              <div className="block">
                <Table>
                  <TableHeader>
                    <TableRow className="border-primary/10">
                      <TableHead className="w-12">
                        <Checkbox
                          checked={
                            appointments.length > 0 &&
                            selectedAppointments.length ===
                              appointments.length
                          }
                          onCheckedChange={handleSelectAll}
                        />
                      </TableHead>
                      <TableHead>Fecha y Hora</TableHead>
                      <TableHead>Paciente</TableHead>
                      <TableHead>Servicio</TableHead>
                      <TableHead>Obra Social</TableHead>
                      <TableHead>Contacto</TableHead>
                      <TableHead>Acciones</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {loadingAppointments ? (
                      <TableRow>
                        <TableCell colSpan={7} className="h-24 text-center">
                          <div className="flex flex-col items-center justify-center">
                            <Loader2 className="h-8 w-8 animate-spin text-primary" />
                            <span className="mt-2">Cargando turnos...</span>
                          </div>
                        </TableCell>
                      </TableRow>
                    ) : sortedAppointments.length === 0 ? (
                      <TableRow>
                        <TableCell colSpan={7} className="h-24 text-center">
                          <div className="flex flex-col items-center justify-center">
                            <CalendarIcon2 className="h-8 w-8 text-muted-foreground" />
                            <span className="mt-2">No hay turnos que coincidan con los filtros seleccionados</span>
                            <Button 
                              variant="link" 
                              className="mt-2"
                              onClick={() => {
                                setSearchQuery('');
                                setDateFilter({ from: undefined, to: undefined });
                                setObraSocialFilter('all');
                              }}
                            >
                              Limpiar filtros
                            </Button>
                          </div>
                        </TableCell>
                      </TableRow>
                    ) : (
                      sortedAppointments.map((appointment) => (
                        <TableRow
                          key={appointment.id}
                          className="border-primary/10"
                        >
                          <TableCell>
                            <Checkbox
                              checked={selectedAppointments.includes(
                            appointment.id,
                          )}
                          onCheckedChange={(checked) =>
                            handleSelectAppointment(
                              appointment.id,
                              checked as boolean,
                            )
                          }
                        />
                      </TableCell>
                      <TableCell 
                        className={`font-medium ${inlineEditId !== appointment.id ? 'cursor-pointer' : ''}`} 
                        onClick={() => {
                          if (inlineEditId !== appointment.id) {
                            handleInlineEdit(appointment.id);
                          }
                        }}
                      >
                        <EditableCell
                          value={format(new Date(appointment.appointmentTime), "PPpp", {
                            locale: es,
                          })}
                          field="appointmentTime"
                          isEditing={inlineEditId === appointment.id}
                          appointment={appointment}
                        />
                      </TableCell>
                      <TableCell 
                        className={inlineEditId !== appointment.id ? 'cursor-pointer' : ''} 
                        onClick={() => {
                          if (inlineEditId !== appointment.id) {
                            handleInlineEdit(appointment.id);
                          }
                        }}
                      >
                        <EditableCell
                          value={appointment.patientName}
                          field="patientName"
                          isEditing={inlineEditId === appointment.id}
                        />
                      </TableCell>
                      <TableCell 
                        className={inlineEditId !== appointment.id ? 'cursor-pointer' : ''} 
                        onClick={() => {
                          if (inlineEditId !== appointment.id) {
                            handleInlineEdit(appointment.id);
                          }
                        }}
                      >
                        <EditableCell
                          value={appointment.serviceType || "Consulta"}
                          field="serviceType"
                          isEditing={inlineEditId === appointment.id}
                        />
                      </TableCell>
                      <TableCell 
                        className={inlineEditId !== appointment.id ? 'cursor-pointer' : ''} 
                        onClick={() => {
                          if (inlineEditId !== appointment.id) {
                            handleInlineEdit(appointment.id);
                          }
                        }}
                      >
                        <EditableCell
                          value={appointment.obraSocial || "Particular"}
                          field="obraSocial"
                          isEditing={inlineEditId === appointment.id}
                        />
                      </TableCell>
                      <TableCell>
                        <div 
                          className={inlineEditId !== appointment.id ? 'cursor-pointer' : ''} 
                          onClick={() => {
                            if (inlineEditId !== appointment.id) {
                              handleInlineEdit(appointment.id);
                            }
                          }}
                        >
                          <EditableCell
                            value={appointment.email || ""}
                            field="email"
                            isEditing={inlineEditId === appointment.id}
                          />
                        </div>
                        <div 
                          className={`text-sm text-muted-foreground ${inlineEditId !== appointment.id ? 'cursor-pointer' : ''}`} 
                          onClick={() => {
                            if (inlineEditId !== appointment.id) {
                              handleInlineEdit(appointment.id);
                            }
                          }}
                        >
                          <EditableCell
                            value={appointment.phone || ""}
                            field="phone"
                            isEditing={inlineEditId === appointment.id}
                          />
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex gap-2">
                          {appointment.patientId && (
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() =>
                                setShowClinicalHistory(appointment.patientId)
                              }
                              className="border-primary/20 hover:bg-primary/5"
                            >
                              <FileText className="h-4 w-4 mr-2" />
                              Historia
                            </Button>
                          )}
                          <Button
                            variant={inlineEditId === appointment.id ? "default" : "outline"}
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation(); // Evitar que el evento se propague
                              if (inlineEditId === appointment.id) {
                                // Si ya estamos editando, guardar cambios
                                console.log("Guardando cambios desde bot√≥n...");
                                saveRowEdits();
                              } else {
                                // Iniciar edici√≥n
                                handleInlineEdit(appointment.id);
                              }
                            }}
                            className={inlineEditId === appointment.id ? "" : "border-primary/20 hover:bg-primary/5"}
                          >
                            {inlineEditId === appointment.id ? (
                              <>
                                <Check className="h-4 w-4 mr-1" />
                                Guardar
                              </>
                            ) : (
                              <>
                                <Edit className="h-4 w-4 mr-1" />
                                Editar
                              </>
                            )}
                          </Button>
                          {inlineEditId === appointment.id && (
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={cancelRowEdit}
                              className="ml-1 border-destructive/20 hover:bg-destructive/5"
                            >
                              <X className="h-4 w-4 mr-1" />
                              Cancelar
                            </Button>
                          )}
                          <Button
                            variant="default"
                            size="sm"
                            onClick={() => setCancelConfirmId(appointment.id)}
                            className="bg-amber-600 hover:bg-amber-700 text-white mr-1"
                            disabled={appointment.status === 'cancelled_by_patient' || appointment.status === 'cancelled_by_professional'}
                          >
                            <XCircle className="h-4 w-4 mr-1" />
                            Cancelar
                          </Button>
                          <Button
                            variant="destructive"
                            size="sm"
                            onClick={() => setDeleteConfirmId(appointment.id)}
                          >
                            <Trash2 className="h-4 w-4 mr-1" />
                            Eliminar
                          </Button>
                        </div>
                      </TableCell>
                        </TableRow>
                      )))}
                  </TableBody>
                </Table>

                <div className="flex items-center justify-center space-x-2 mt-4">
                  <Button
                    variant="outline"
                    onClick={() => setAppointmentsPage(Math.max(0, appointmentsPage - 1))}
                    disabled={appointmentsPage === 0}
                    className="border-primary/20 hover:bg-primary/5"
                  >
                    <ChevronLeft className="h-4 w-4" />
                    Anterior
                  </Button>
                  <div className="flex items-center space-x-1">
                    {Array.from({ length: Math.min(5, totalFilteredPages) }, (_, i) => {
                      // Calculate page number to show (for pagination with many pages)
                      const pageIndex = appointmentsPage < 3
                        ? i
                        : appointmentsPage + i - 2 >= totalFilteredPages 
                          ? totalFilteredPages - 5 + i
                          : appointmentsPage + i - 2;

                      return pageIndex >= 0 && pageIndex < totalFilteredPages ? (
                        <Button
                          key={pageIndex}
                          variant={appointmentsPage === pageIndex ? "default" : "outline"}
                          onClick={() => setAppointmentsPage(pageIndex)}
                          className={cn(
                            "w-9 h-9 p-0",
                            appointmentsPage === pageIndex 
                              ? "bg-primary text-white" 
                              : "border-primary/20"
                          )}
                        >
                          {pageIndex + 1}
                        </Button>
                      ) : null;
                    })}
                  </div>
                  <Button
                    variant="outline"
                    onClick={() => setAppointmentsPage(Math.min(totalFilteredPages - 1, appointmentsPage + 1))}
                    disabled={appointmentsPage >= totalFilteredPages - 1}
                    className="border-primary/20 hover:bg-primary/5"
                  >
                    Siguiente
                    <ChevronRight className="h-4 w-4 ml-2" />
                  </Button>
                </div>
              </div>
            </>
          ) : (
            <>
              <div className="space-y-4">
                <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 gap-3">
                  <div className="flex flex-wrap items-center gap-2">
                    <Button
                      variant="outline"
                      onClick={goToPreviousWeek}
                      className="border-primary/20 text-xs sm:text-sm"
                      size="sm"
                    >
                      <ChevronLeft className="h-3 h-3 sm:h-4 sm:w-4 mr-1 sm:mr-2" />
                      <span className="hidden sm:inline">Semana anterior</span>
                      <span className="sm:hidden">Anterior</span>
                    </Button>
                    {scheduleConfig?.occasionalWorkDays && 
                     Array.isArray(scheduleConfig.occasionalWorkDays) && 
                     scheduleConfig.occasionalWorkDays.length > 0 && (
                      <Button
                        variant="outline"
                        onClick={() => {
                          try {
                            // Navegar a la semana que contiene el primer d√≠a eventual
                            const dateStr = scheduleConfig.occasionalWorkDays[0];
                            console.log("Navegando al d√≠a eventual:", dateStr);
                            
                            // Asegurarse de procesar correctamente la fecha: usar yyyy-MM-dd
                            const [year, month, day] = dateStr.split('-').map(num => parseInt(num, 10));
                            // Crear una nueva fecha con los componentes (mes es 0-indexado en JavaScript)
                            const eventualDate = new Date(year, month - 1, day, 12, 0, 0);
                            
                            if (isNaN(eventualDate.getTime())) {
                              console.error("Fecha inv√°lida generada:", eventualDate);
                              toast({
                                title: "Error de navegaci√≥n",
                                description: "No se pudo procesar la fecha correctamente",
                                variant: "destructive"
                              });
                              return;
                            }
                            
                            console.log("Fecha eventual parseada:", eventualDate);
                            setSelectedWeek(eventualDate);
                            toast({
                              title: "Navegando a d√≠a eventual",
                              description: `Mostrando semana con el d√≠a eventual: ${format(eventualDate, "EEEE d 'de' MMMM", { locale: es })}`,
                            });
                          } catch (error) {
                            console.error("Error al navegar a d√≠a eventual:", error);
                            toast({
                              title: "Error",
                              description: "No se pudo navegar al d√≠a eventual",
                              variant: "destructive"
                            });
                          }
                        }}
                        className="border-green-300 bg-green-50 text-green-700 hover:bg-green-100 text-xs"
                        size="sm"
                      >
                        <CalendarIcon className="h-3 w-3 mr-1" />
                        <span className="hidden sm:inline">Ir a d√≠a eventual</span>
                        <span className="sm:hidden">D√≠a eventual</span>
                      </Button>
                    )}
                    <h3 className="text-sm sm:text-lg font-medium">
                      <span className="hidden sm:inline">Semana: </span>
                      {format(weekStart, "d MMM", { locale: es })} - {format(weekEnd, "d MMM", { locale: es })}
                      {daysInWeek.length > 0 && (
                        <span className="ml-2 bg-primary/10 text-primary px-2 py-1 rounded-full text-xs">
                          Mi√©rcoles {format(daysInWeek[0], "d 'de' MMMM", { locale: es })}
                        </span>
                      )}
                    </h3>
                    <Button
                      variant="outline"
                      onClick={goToNextWeek}
                      className="border-primary/20 text-xs sm:text-sm"
                      size="sm"
                    >
                      <span className="hidden sm:inline">Siguiente semana</span>
                      <span className="sm:hidden">Siguiente</span>
                      <ChevronRight className="h-3 h-3 sm:h-4 sm:w-4 ml-1 sm:ml-2" />
                    </Button>
                  </div>
                  
                  <Button
                    variant="outline"
                    onClick={() => {
                      toast({
                        title: "Sincronizando...",
                        description: "Sincronizando con Google Calendar"
                      });
                      syncCalendarMutation.mutate();
                    }}
                    disabled={syncCalendarMutation.isPending}
                    className="border-primary/20 hover:bg-primary/5 flex items-center gap-2 text-xs sm:text-sm w-full sm:w-auto"
                    size="sm"
                  >
                    {syncCalendarMutation.isPending ? (
                      <Loader2 className="h-3 w-3 sm:h-4 sm:w-4 animate-spin" />
                    ) : (
                      <RefreshCw className="h-3 w-3 sm:h-4 sm:w-4" />
                    )}
                    <span>Sincronizar con Google Calendar</span>
                  </Button>
                </div>

                {/* Full week calendar view */}
                <div className="border rounded-lg border-primary/10 shadow-sm overflow-hidden">
                  {/* Header row with day names */}
                  <div className="grid grid-cols-5 bg-secondary/30">
                    {daysInWeek.map((day) => {
                      // Formatear la fecha para usarla como clave en el mapa de d√≠as bloqueados
                      const dateKey = format(day, "yyyy-MM-dd");
                      // Encontrar si este d√≠a est√° bloqueado
                      const blockedDay = blockedDays.find(d => d.date.split('T')[0] === dateKey);
                      const isBlocked = !!blockedDay;
                      
                      // Verificar si es un d√≠a eventual
                      const isOccasionalWorkDay = scheduleConfig?.occasionalWorkDays?.includes(dateKey) || false;
                      
                      return (
                        <div 
                          key={day.toISOString()} 
                          className={`text-center font-medium p-2 sm:p-4 border-r border-primary/10 last:border-r-0 
                            ${isBlocked ? 'bg-red-100 relative' : ''} 
                            ${isOccasionalWorkDay ? 'bg-green-50 relative' : ''}`}
                        >
                          {isBlocked && (
                            <div className="absolute inset-0 pointer-events-none bg-red-100 bg-[repeating-linear-gradient(45deg,transparent,transparent_10px,rgba(255,0,0,0.1)_10px,rgba(255,0,0,0.1)_20px)]">
                            </div>
                          )}
                          {isOccasionalWorkDay && (
                            <div className="absolute inset-0 pointer-events-none">
                              {/* Etiqueta para indicar que es un d√≠a eventual (ahora en la parte superior) */}
                              <div className="absolute top-0 left-0 right-0 bg-green-500 text-white text-xs px-2 py-1 rounded-b-md text-center font-semibold z-10">
                                ¬°D√≠a Eventual!
                                <div className="font-medium text-xs">
                                  {format(day, "d 'de' MMMM", { locale: es })}
                                </div>
                              </div>
                              {/* Borde verde para destacar que es un d√≠a eventual */}
                              <div className="absolute inset-0 border-2 border-green-500 rounded-md"></div>
                              {/* Indicador visual para reforzar que es d√≠a eventual */}
                              <div className="absolute top-4 right-0 w-3 h-3 bg-green-500 rounded-full m-1 animate-pulse" />
                            </div>
                          )}
                          <div className="text-primary text-sm sm:text-lg mb-0 sm:mb-1">
                            <span className="hidden sm:inline">{format(day, "EEEE", { locale: es })}</span>
                            <span className="sm:hidden">{format(day, "E", { locale: es })}</span>
                          </div>
                          <div className="text-xs sm:text-sm truncate max-w-full">
                            <span className="hidden sm:inline">{format(day, "d 'de' MMMM", { locale: es })}</span>
                            <span className="sm:hidden">{format(day, "d MMM", { locale: es })}</span>
                          </div>
                          
                          {/* Toggle para bloquear/desbloquear el d√≠a */}
                          <div className="flex items-center justify-center mt-2 gap-2">
                            <Switch
                              checked={isBlocked}
                              onCheckedChange={(checked) => {
                                // Simplifiquemos temporalmente mientras arreglamos los problemas de API
                                toast({
                                  title: checked ? "D√≠a bloqueado" : "D√≠a desbloqueado",
                                  description: `Has ${checked ? 'bloqueado' : 'desbloqueado'} el d√≠a ${format(day, "d 'de' MMMM", { locale: es })}.`,
                                  variant: checked ? "destructive" : "default"
                                });
                                
                                // Simulaci√≥n visual: incluimos d√≠a en bloqueos locales
                                if (checked) {
                                  // Simulamos agregar un d√≠a bloqueado
                                  setBlockedDays(prev => [...prev, {
                                    id: Math.floor(Math.random() * 1000), // ID simulado
                                    date: format(day, "yyyy-MM-dd"),
                                    reason: "D√≠a no disponible" // Raz√≥n por defecto
                                  }]);
                                } else if (blockedDay) {
                                  // Simulamos quitar un d√≠a bloqueado
                                  setBlockedDays(prev => prev.filter(d => d.id !== blockedDay.id));
                                }
                              }}
                              className={`${isBlocked ? 'bg-red-500' : ''}`}
                            />
                            <span className="text-xs">
                              {isBlocked ? 'Bloqueado' : 'Disponible'}
                            </span>
                          </div>
                        </div>
                      );
                    })}
                  </div>

                  {/* Time slots grid */}
                  <div className="relative">
                    {/* Time indicators column */}
                    <div className="absolute left-0 top-0 bottom-0 w-12 sm:w-20 bg-secondary/10 border-r border-primary/10 flex flex-col">
                      {timeSlots.map((slot) => (
                        <div 
                          key={`time-${slot.hour}-${slot.minute}`} 
                          className="h-16 sm:h-24 flex items-center justify-center text-xs sm:text-sm font-medium border-b border-primary/10 last:border-b-0"
                        >
                          <div className="flex flex-col items-center">
                            <span className="text-primary font-bold">{slot.hour.toString().padStart(2, '0')}</span>
                            <span className="text-[10px] sm:text-xs text-muted-foreground">{slot.minute === 0 ? '00' : slot.minute}</span>
                          </div>
                        </div>
                      ))}
                    </div>

                    {/* Calendar grid */}
                    <div className="ml-12 sm:ml-20 grid grid-cols-5">
                      {/* Generate columns for each day */}
                      {daysInWeek.map((day) => (
                        <div key={`col-${day.toISOString()}`} className="border-r border-primary/10 last:border-r-0">
                          {/* Generate time slots for this day */}
                          {timeSlots.map((slot) => {
                            const timeStr = `${slot.hour.toString().padStart(2, '0')}:${slot.minute === 0 ? '00' : slot.minute}`;

                            // Get appointments for this specific time slot
                            // Citas que comienzan exactamente en este slot
                            const appointmentsForTime = getAppointmentsForDay(day).filter((apt) => {
                              const aptDate = new Date(apt.appointmentTime);
                              return aptDate.getHours() === slot.hour && aptDate.getMinutes() === slot.minute;
                            });
                            
                            // Citas de 40 minutos que abarcan este slot pero comienzan en otro anterior
                            const overlapFortyAppts = appointments.filter(apt => {
                              // Solo nos interesan citas de 40 minutos
                              if (!isFortyMinService(apt.serviceType || "")) return false;
                              
                              const aptDate = new Date(apt.appointmentTime);
                              if (!isSameDay(aptDate, day)) return false;
                              
                              const aptHour = aptDate.getHours();
                              const aptMinute = aptDate.getMinutes();
                              const aptTimeInMinutes = aptHour * 60 + aptMinute;
                              
                              const slotTimeInMinutes = slot.hour * 60 + slot.minute;
                              
                              // Este slot est√° en la segunda o tercera posici√≥n (9:20 o 9:40 para una cita de 9:00)
                              return slotTimeInMinutes > aptTimeInMinutes && 
                                     slotTimeInMinutes <= aptTimeInMinutes + 40 && 
                                     slotTimeInMinutes !== aptTimeInMinutes;
                            });
                            
                            // Determinar si este slot est√° ocupado por una cita de 40 min que comienza antes
                            const occupiedByFortyMin = overlapFortyAppts.length > 0;
                            
                            // La cita principal que ocupa este slot (si es parte de una cita de 40 min)
                            const mainAppointment = occupiedByFortyMin ? overlapFortyAppts[0] : undefined;
                            
                            // Calcular la posici√≥n relativa en el bloque de 40 min
                            let positionInForty: 'first' | 'middle' | 'last' | undefined;
                            
                            if (occupiedByFortyMin && mainAppointment) {
                              const aptDate = new Date(mainAppointment.appointmentTime);
                              const aptTimeInMinutes = aptDate.getHours() * 60 + aptDate.getMinutes();
                              const slotTimeInMinutes = slot.hour * 60 + slot.minute;
                              
                              if (slotTimeInMinutes === aptTimeInMinutes + 20) {
                                positionInForty = 'middle';
                              } else if (slotTimeInMinutes === aptTimeInMinutes + 40) {
                                positionInForty = 'last';
                              }
                            }

                            // Comprobar si hay una cita en este slot que estamos editando
                            const appointmentInEdit = editingAppointment && appointmentsForTime.some(apt => apt.id === editingAppointment.id);
                            
                            // Un slot est√° disponible si no hay citas o si la √∫nica cita es la que estamos editando
                            let isAvailable = isTimeSlotAvailable(day, slot.hour, slot.minute, appointments);
                            
                            // Si hay una cita en este slot que estamos editando, siempre permitir la selecci√≥n
                            const isSelectable = isAvailable || appointmentInEdit;

                            // Verificar si el d√≠a est√° bloqueado
                            const dateKey = format(day, "yyyy-MM-dd");
                            const blockedDay = blockedDays.find(d => d.date.split('T')[0] === dateKey);
                            const isDayBlocked = !!blockedDay;

                            return (
                              <div
                                key={`slot-${day.toISOString()}-${timeStr}`}
                                className={cn(
                                  "h-16 sm:h-24 p-1 sm:p-2 border-b border-primary/10 transition-colors relative",
                                  // Si el d√≠a est√° bloqueado, mostrar un fondo con patr√≥n de rayas
                                  isDayBlocked 
                                    ? "bg-red-50 cursor-not-allowed" 
                                    : isSelectable
                                        ? "hover:bg-secondary/30 cursor-pointer" 
                                        : "bg-gray-50",
                                  appointmentInEdit && "ring-2 ring-primary/50" // Resaltar si contiene la cita en edici√≥n
                                )}
                                style={isDayBlocked ? {
                                  backgroundImage: 'repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,0,0,0.1) 10px, rgba(255,0,0,0.1) 20px)'
                                } : {}}
                                onClick={() => {
                                  if (isSelectable) {
                                    // Format time string properly with leading zeros
                                    const formattedTimeStr = `${slot.hour.toString().padStart(2, '0')}:${slot.minute === 0 ? '00' : slot.minute}`;
                                    
                                    // Si hay turnos en este horario, mostrar el primero en el formulario r√°pido
                                    if (appointmentsForTime.length > 0) {
                                      setQuickFormSlot({
                                        timeStr: formattedTimeStr,
                                        date: new Date(day),
                                        appointment: appointmentsForTime[0]
                                      });
                                      return;
                                    }
                                    
                                    // Si no hay turnos, mostrar formulario para crear nuevo
                                    setQuickFormSlot({
                                      timeStr: formattedTimeStr,
                                      date: new Date(day)
                                    });
                                  }
                                }}
                              >
                                {/* Verificar si hay un formulario r√°pido activo para este slot */}
                                {quickFormSlot && quickFormSlot.timeStr === timeStr && isSameDay(quickFormSlot.date, day) ? (
                                  // Si hay una cita en quickFormSlot, estamos editando
                                  quickFormSlot.appointment ? (
                                    <NewQuickAppointmentForm 
                                      date={new Date(day)}
                                      timeStr={timeStr}
                                      mode="edit"
                                      initialData={quickFormSlot.appointment}
                                      onSubmit={(data: InsertAppointment) => {
                                        console.log("Enviando datos editados:", data);
                                        // Asegurar que notes es un string no undefined
                                        if (quickFormSlot.appointment) {
                                          editMutation.mutate({ 
                                            id: quickFormSlot.appointment.id, 
                                            data: {
                                              ...data,
                                              notes: data.notes || ""
                                            }
                                          });
                                        }
                                        setQuickFormSlot(null); // Cerrar formulario despu√©s de enviar
                                      }}
                                      onCancel={() => {
                                        console.log("Cancelando edici√≥n r√°pida");
                                        setQuickFormSlot(null);
                                      }}
                                      onDelete={(id: number) => {
                                        setDeleteConfirmId(id);
                                        setQuickFormSlot(null);
                                      }}
                                      isPending={editMutation.isPending}
                                    />
                                  ) : (
                                    // Si no hay cita, estamos creando una nueva
                                    <NewQuickAppointmentForm 
                                      date={new Date(day)}
                                      timeStr={timeStr}
                                      onSubmit={(data: InsertAppointment) => {
                                        console.log("Enviando datos del formulario r√°pido:", data);
                                        // Asegurar que notes es un string no undefined
                                        const appointment: InsertAppointment = {
                                          ...data,
                                          notes: data.notes || ""
                                        };
                                        createAppointmentMutation.mutate(appointment);
                                        setQuickFormSlot(null); // Cerrar formulario despu√©s de enviar
                                      }}
                                      onCancel={() => {
                                        console.log("Cancelando formulario r√°pido");
                                        setQuickFormSlot(null);
                                      }}
                                      isPending={createAppointmentMutation.isPending}
                                    />
                                  )
                                ) : appointmentsForTime.length > 0 ? (
                                  <div className="absolute inset-1 bg-primary/10 rounded-md shadow-sm p-1 overflow-hidden flex flex-col">
                                    {appointmentsForTime.map((apt) => (
                                      <CalendarAppointment
                                        key={`apt-list-${apt.id}`}
                                        appointment={apt}
                                        onCancel={setCancelConfirmId}
                                        onNoShow={(id) => noShowMutation.mutate(id)}
                                        onAttended={(id) => attendedMutation.mutate(id)}
                                        onEdit={(appointment) => {
                                          // Obtener la hora y fecha de la cita
                                          const aptDate = new Date(appointment.appointmentTime);
                                          const hour = aptDate.getHours();
                                          const minute = aptDate.getMinutes();
                                          const timeStr = `${hour.toString().padStart(2, '0')}:${minute === 0 ? '00' : minute}`;
                                          
                                          // Establecer el quickFormSlot para usar el formulario r√°pido
                                          setQuickFormSlot({
                                            timeStr: timeStr,
                                            date: aptDate,
                                            appointment: appointment
                                          });
                                        }}
                                        onDelete={(id) => setDeleteConfirmId(id)}
                                        onDetails={(appointment) => setSelectedAppointment(appointment)}
                                      />
                                    ))}
                                  </div>
                                ) : occupiedByFortyMin && mainAppointment ? (
                                  // Mostrar que este slot est√° ocupado por un turno de 40 minutos que comienza antes
                                  <div className="absolute inset-1 bg-orange-100 rounded-md shadow-sm p-1 overflow-hidden flex items-center justify-center">
                                    <div className="text-center">
                                      <div className="text-xs font-medium text-orange-700 flex items-center justify-center">
                                        <Timer className="h-3 w-3 mr-1" />
                                        {positionInForty === 'middle' ? 'Contin√∫a' : 'Finaliza'} turno
                                      </div>
                                      <div className="text-[10px] mt-1 bg-orange-50 border border-orange-200 rounded p-1 text-orange-800">
                                        <strong>{mainAppointment.patientName}</strong>
                                        <div>
                                          {mainAppointment.serviceType === "Extracci√≥n & Colocaci√≥n de DIU" ? "DIU" : 
                                           mainAppointment.serviceType === "Terapia de Ginecolog√≠a Regenerativa" ? "Terapia" : 
                                           mainAppointment.serviceType}
                                        </div>
                                        <div className="text-orange-600 mt-1 border-t border-orange-200 pt-1 flex justify-center">
                                          <Clock className="h-2 w-2 mr-1 mt-0.5" />
                                          {format(new Date(mainAppointment.appointmentTime), "HH:mm", { locale: es })}
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                ) : (
                                  <div className={cn(
                                    "absolute inset-0 flex items-center justify-center text-sm rounded-md border-2 border-dashed m-1 transition-all", 
                                    isSelectable 
                                      ? "border-primary/40 text-primary hover:border-primary hover:bg-primary/5 hover:shadow-md" 
                                      : "border-gray-200 text-gray-400"
                                  )}>
                                    {isSelectable ? (
                                      <div className="flex flex-col items-center p-1 sm:p-2">
                                        <Clock className="h-4 w-4 sm:h-5 sm:w-5 mb-0 sm:mb-1 text-primary/70" />
                                        <span className="font-medium text-xs sm:text-sm">{timeStr}</span>
                                        <span className="text-[10px] sm:text-xs bg-primary/10 text-primary font-medium px-1 sm:px-2 py-0.5 rounded-full mt-0 sm:mt-1">
                                          {appointmentInEdit ? "Editar" : "Libre"}
                                        </span>
                                      </div>
                                    ) : (
                                      <div className="flex flex-col items-center">
                                        <span className="font-medium text-xs sm:text-sm">No disponible</span>
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            </>
          )}
        </CardContent>
      </Card>

      <Dialog
        open={!!deleteConfirmId}
        onOpenChange={() => setDeleteConfirmId(null)}
      >
        <DialogContent className="border-primary/10">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminaci√≥n</DialogTitle>
            <DialogDescription>
              ¬øEst√° seguro que desea eliminar este turno? Esta acci√≥n no se
              puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setDeleteConfirmId(null)}
              className="border-primary/20 hover:bg-primary/5"
            >
              Cancelar
            </Button>
            <Button
              variant="destructive"
              onClick={() => {
                deleteMutation.mutate(deleteConfirmId);
                // Ya no cerramos aqu√≠ el di√°logo, lo hacemos en el onSuccess para evitar duplicaciones
              }}
              disabled={deleteMutation.isPending}
            >
              {deleteMutation.isPending ? (
                <span className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Eliminando...
                </span>
              ) : (
                "Eliminar"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog
        open={!!cancelConfirmId}
        onOpenChange={() => setCancelConfirmId(null)}
      >
        <DialogContent className="border-primary/10">
          <DialogHeader>
            <DialogTitle>Confirmar Cancelaci√≥n de Turno</DialogTitle>
            <DialogDescription>
              ¬øEst√° seguro que desea cancelar este turno? Se enviar√° una notificaci√≥n por email al paciente
              informando que la cita ha sido cancelada por la profesional.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setCancelConfirmId(null)}
              className="border-primary/20 hover:bg-primary/5"
            >
              Volver
            </Button>
            <Button
              variant="default"
              className="bg-amber-600 hover:bg-amber-700 text-white"
              onClick={() => {
                cancelMutation.mutate(cancelConfirmId);
              }}
              disabled={cancelMutation.isPending}
            >
              {cancelMutation.isPending ? (
                <span className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Procesando...
                </span>
              ) : (
                "Confirmar Cancelaci√≥n"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog
        open={showBulkDeleteConfirm}
        onOpenChange={setShowBulkDeleteConfirm}
      >
        <DialogContent className="border-primary/10">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminaci√≥n M√∫ltiple</DialogTitle>
            <DialogDescription>
              ¬øEst√° seguro que desea eliminar {selectedAppointments.length}{" "}
              turnos? Esta acci√≥n no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setShowBulkDeleteConfirm(false)}
              className="border-primary/20 hover:bg-primary/5"
            >
              Cancelar
            </Button>
            <Button
              variant="destructive"
              onClick={() => bulkDeleteMutation.mutate(selectedAppointments)}
              disabled={bulkDeleteMutation.isPending}
            >
              {bulkDeleteMutation.isPending ? (
                <span className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Eliminando...
                </span>
              ) : (
                "Eliminar"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <Dialog
        open={!!noShowConfirmId}
        onOpenChange={() => setNoShowConfirmId(null)}
      >
        <DialogContent className="border-primary/10">
          <DialogHeader>
            <DialogTitle>Confirmar ausencia del paciente</DialogTitle>
            <DialogDescription>
              ¬øEst√° seguro que desea marcar que el paciente no asisti√≥ a esta cita?
              Esta acci√≥n registrar√° la ausencia y se contabilizar√° en las estad√≠sticas.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setNoShowConfirmId(null)}
              className="border-primary/20 hover:bg-primary/5"
            >
              Volver
            </Button>
            <Button
              variant="default"
              className="bg-purple-600 hover:bg-purple-700 text-white"
              onClick={() => {
                noShowMutation.mutate(noShowConfirmId);
              }}
              disabled={noShowMutation.isPending}
            >
              {noShowMutation.isPending ? (
                <span className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Procesando...
                </span>
              ) : (
                "Confirmar ausencia"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={showLogoutConfirm} onOpenChange={setShowLogoutConfirm}>
        <DialogContent className="border-primary/10">
          <DialogHeader>
            <div className="space-y-2">
              <DialogTitle>Confirmar cierre de sesi√≥n</DialogTitle>
              <DialogDescription>
                ¬øEst√° seguro que desea cerrar sesi√≥n?
              </DialogDescription>
            </div>
          </DialogHeader>
          <DialogFooter className="flex justify-center gap-3 mt-4">
            <Button
              variant="outline"
              onClick={() => setShowLogoutConfirm(false)}
              className="border-primary/20 hover:bg-primary/5"
            >
              Cancelar
            </Button>
            <Button
              variant="destructive"
              onClick={() => logoutMutation.mutate()}
              disabled={logoutMutation.isPending}
            >
              {logoutMutation.isPending ? (
                <span className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Cerrando sesi√≥n...
                </span>
              ) : (
                "Cerrar sesi√≥n"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog
        open={!!selectedAppointment}
        onOpenChange={() => setSelectedAppointment(null)}
      >
        <DialogContent className="border-primary/10 max-w-lg">
          <DialogHeader>
            <DialogTitle className="text-primary text-xl">Detalles del Turno</DialogTitle>
          </DialogHeader>
          {selectedAppointment && (
            <div className="space-y-4 mt-2">
              <div className="bg-secondary/20 p-4 rounded-lg">
                <div className="flex items-center gap-2 mb-2">
                  <CalendarIcon2 className="h-5 w-5 text-primary" />
                  <div className="font-semibold text-primary">Fecha y Hora</div>
                </div>
                <div className="ml-7 text-lg">
                  {format(
                    new Date(selectedAppointment.appointmentTime),
                    "PPP 'a las' HH:mm",
                    { locale: es },
                  )}
                </div>
              </div>

              <div className="bg-secondary/20 p-4 rounded-lg">
                <div className="flex items-center gap-2 mb-2">
                  <User className="h-5 w-5 text-primary" />
                  <div className="font-semibold text-primary">Paciente</div>
                </div>
                <div className="ml-7 text-lg">{selectedAppointment.patientName}</div>

                <div className="mt-3 space-y-2">
                  {selectedAppointment.isFirstTime && (
                    <div className="ml-7 inline-flex items-center bg-primary/10 text-primary text-sm rounded-full px-3 py-1">
                      Primera consulta
                    </div>
                  )}
                </div>
              </div>

              <div className="bg-secondary/20 p-4 rounded-lg">
                <div className="flex items-center gap-2 mb-2">
                  <div className="font-semibold text-primary">Detalles de la consulta</div>
                </div>
                <div className="ml-7 space-y-2">
                  <div className="flex items-center gap-2">
                    <Stethoscope className="h-4 w-4 text-muted-foreground" />
                    <span className="text-muted-foreground">{selectedAppointment.serviceType}</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <Building2 className="h-4 w-4 text-muted-foreground" />
                    <span className="text-muted-foreground">{selectedAppointment.obraSocial}</span>
                  </div></div></div>

              {selectedAppointment.notes && (
                <div className="bg-secondary/20 p-4 rounded-lg">
                  <div className="flex items-center gap-2 mb-2">
                    <StickyNote className="h-5 w-5 text-primary" />
                    <div className="font-semibold text-primary">Notas</div>
                  </div>
                  <div className="ml-7 text-muted-foreground whitespace-pre-wrap">{selectedAppointment.notes}</div>
                </div>
              )}

              <DialogFooter className="flex flex-wrap gap-2 pt-4 justify-end">
                {selectedAppointment.patientId && (
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowClinicalHistory(selectedAppointment.patientId);
                      setSelectedAppointment(null);
                    }}
                    className="border-primary/20 hover:bg-primary/5"
                  >
                    <FileText className="h-4 w-4 mr-2" />
                    Historia Cl√≠nica
                  </Button>
                )}

                <Button
                  variant="outline"
                  onClick={() => {
                    reminderMutation.mutate(selectedAppointment.id);
                  }}
                  className="border-primary/20 hover:bg-primary/5"
                  disabled={reminderMutation.isPending}
                >
                  <Bell className="h-4 w-4 mr-2" />
                  {reminderMutation.isPending ? "Enviando..." : "Enviar Recordatorio"}
                </Button>

                <Button
                  variant="outline"
                  onClick={() => {
                    setEditingAppointment(selectedAppointment);
                    setSelectedAppointment(null);
                  }}
                  className="border-primary/20 hover:bg-primary/5"
                >
                  <Edit className="h-4 w-4 mr-2" />
                  Editar
                </Button>

                <Button
                  variant="default"
                  className="bg-amber-600 hover:bg-amber-700 text-white"
                  onClick={() => {
                    setCancelConfirmId(selectedAppointment.id);
                    setSelectedAppointment(null);
                  }}
                  size="sm"
                  disabled={selectedAppointment.status === 'cancelled_by_patient' || selectedAppointment.status === 'cancelled_by_professional'}
                >
                  <XCircle className="h-4 w-4 mr-2" />
                  Cancelar Turno
                </Button>

                <Button
                  variant="default"
                  className="bg-green-600 hover:bg-green-700 text-white"
                  onClick={() => {
                    attendedMutation.mutate(selectedAppointment.id);
                    setSelectedAppointment(null);
                  }}
                  size="sm"
                  disabled={selectedAppointment.status === 'attended' || selectedAppointment.status === 'no_show' || selectedAppointment.status === 'cancelled_by_patient' || selectedAppointment.status === 'cancelled_by_professional'}
                >
                  <Check className="h-4 w-4 mr-2" />
                  Asisti√≥
                </Button>

                <Button
                  variant="default"
                  className="bg-purple-600 hover:bg-purple-700 text-white"
                  onClick={() => {
                    setNoShowConfirmId(selectedAppointment.id);
                    setSelectedAppointment(null);
                  }}
                  size="sm"
                  disabled={selectedAppointment.status === 'no_show' || selectedAppointment.status === 'cancelled_by_patient' || selectedAppointment.status === 'cancelled_by_professional' || selectedAppointment.status === 'attended'}
                >
                  <User className="h-4 w-4 mr-2" />
                  No asisti√≥
                </Button>

                <Button
                  variant="destructive"
                  onClick={() => {
                    setDeleteConfirmId(selectedAppointment.id);
                    setSelectedAppointment(null);
                  }}
                  size="sm"
                >
                  <Trash2 className="h-4 w-4 mr-2" />
                  Eliminar
                </Button>
              </DialogFooter>
            </div>
          )}
        </DialogContent>
      </Dialog>

      <Dialog
        open={showScheduleSettings}
        onOpenChange={setShowScheduleSettings}
      >
        <DialogContent className="max-w-3xl">
          <DialogHeader>
            <DialogTitle>Configuraci√≥n</DialogTitle>
            <DialogDescription>
              Configure los horarios de atenci√≥n, per√≠odos de vacaciones y
              mensajes para pacientes
            </DialogDescription>
          </DialogHeader>

          <Tabs defaultValue="account" className="mt-4">
            <TabsList className="grid w-full grid-cols-5">
              <TabsTrigger value="account">Mi Cuenta</TabsTrigger>
              <TabsTrigger value="google-calendar">Google Calendar</TabsTrigger>
              <TabsTrigger value="schedule">Horarios de atenci√≥n</TabsTrigger>
              <TabsTrigger value="vacation">Per√≠odo de vacaciones</TabsTrigger>
              <TabsTrigger value="messages">Mensajes a pacientes</TabsTrigger>
            </TabsList>

            <TabsContent value="schedule" className="space-y-4 mt-4">
              <Form {...scheduleForm}>
                <form
                  onSubmit={scheduleForm.handleSubmit(() => {
                    if (editedConfig) {
                      updateScheduleMutation.mutate(editedConfig);
                    }
                  })}
                  className="space-y-4"
                >
                  <div className="grid grid-cols-2 gap-4">
                    <FormField
                      control={scheduleForm.control}
                      name="startTime"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Hora de inicio</FormLabel>
                          <FormControl>
                            <Input type="time" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={scheduleForm.control}
                      name="endTime"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Hora de fin</FormLabel>
                          <FormControl>
                            <Input type="time" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <div className="space-y-2">
                    <FormLabel>D√≠as de atenci√≥n habituales</FormLabel>
                    <div className="flex flex-wrap gap-2">
                      {["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes"].map(
                        (day) => (
                          <Button
                            key={day}
                            type="button"
                            variant={
                              scheduleConfig?.workDays.includes(day.toLowerCase())
                                ? "default"
                                : "outline"
                            }
                            onClick={() => {
                              const newWorkDays =
                                scheduleConfig?.workDays.includes(
                                  day.toLowerCase(),
                                )
                                  ? scheduleConfig.workDays.filter(
                                      (d) => d !== day.toLowerCase(),
                                    )
                                  : [
                                      ...(scheduleConfig?.workDays || []),
                                      day.toLowerCase(),
                                    ];

                              updateScheduleMutation.mutate({
                                workDays: newWorkDays,
                              });
                            }}
                            className="border-primary/20"
                          >
                            {day}
                          </Button>
                        ),
                      )}
                    </div>
                  </div>
                  
                  <div className="space-y-2 mt-6 border-t pt-4">
                    <FormLabel>D√≠as de atenci√≥n eventuales</FormLabel>
                    <p className="text-sm text-muted-foreground whitespace-normal">
                      Configure d√≠as espec√≠ficos para atender fuera del horario habitual.
                    </p>
                    
                    <div className="grid gap-4 mt-2">
                      <div className="flex items-center gap-4">
                        <Popover>
                          <PopoverTrigger asChild>
                            <Button
                              variant="outline"
                              className="border-primary/20 w-full justify-start text-left font-normal"
                            >
                              <CalendarIcon2 className="mr-2 h-4 w-4" />
                              Seleccionar fecha eventual
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={undefined}
                              disabled={{
                                // No deshabilitar ning√∫n d√≠a para permitir agregar cualquier d√≠a como eventual
                                // Solo filtramos despu√©s en la l√≥gica de selecci√≥n
                                before: new Date()
                              }}
                              modifiers={{
                                // D√≠as de trabajo eventuales
                                occasionalWorkDay: (date) => {
                                  const dateStr = format(date, "yyyy-MM-dd");
                                  return scheduleConfig?.occasionalWorkDays?.includes(dateStr) || false;
                                },
                                // D√≠as bloqueados
                                blocked: (date) => {
                                  const dateStr = format(date, "yyyy-MM-dd");
                                  return blockedDays.some(day => day.date.split('T')[0] === dateStr);
                                },
                                // D√≠as de trabajo regulares
                                workingday: (date) => {
                                  // Normalizar el nombre del d√≠a
                                  const dayName = format(date, "EEEE", { locale: es })
                                    .toLowerCase()
                                    .normalize("NFD")
                                    .replace(/[\u0300-\u036f]/g, "");
                                  return scheduleConfig?.workDays.includes(dayName) || false;
                                }
                              }}
                              onSelect={(date) => {
                                if (!date) return;
                                
                                console.log("üîç D√≠a eventual seleccionado:", date);
                                
                                // Solo permitimos agregar d√≠as futuros
                                if (isBefore(date, startOfDay(new Date()))) {
                                  toast({
                                    title: "Fecha inv√°lida",
                                    description: "Solo puede agregar d√≠as eventuales en el futuro",
                                    variant: "destructive"
                                  });
                                  return;
                                }
                                
                                try {
                                  // Formatear la fecha como ISO string para guardarla
                                  const dateStr = format(date, "yyyy-MM-dd");
                                  console.log("üîç Formato de fecha a guardar:", dateStr);
                                  
                                  // Verificar si ya existe en la lista
                                  const exists = scheduleConfig?.occasionalWorkDays?.includes(dateStr);
                                  
                                  if (exists) {
                                    toast({
                                      title: "Fecha ya agregada",
                                      description: "Esta fecha ya est√° en la lista de d√≠as eventuales",
                                      variant: "destructive"
                                    });
                                    return;
                                  }
                                  
                                  if (!scheduleConfig) {
                                    toast({
                                      title: "Error de configuraci√≥n",
                                      description: "No se pudo obtener la configuraci√≥n actual",
                                      variant: "destructive"
                                    });
                                    return;
                                  }
                                  
                                  // Mostrar di√°logo para configurar horarios del d√≠a eventual
                                  setNewOccasionalDay(dateStr);
                                  setOccasionalDayStartTime(scheduleConfig.startTime.substring(0, 5));
                                  setOccasionalDayEndTime(scheduleConfig.endTime.substring(0, 5));
                                  setShowOccasionalDayTimeDialog(true);
                                  return;
                                    onSuccess: () => {
                                      console.log("‚úÖ D√≠a eventual agregado correctamente");
                                      toast({
                                        title: "D√≠a eventual agregado",
                                        description: `Se agreg√≥ el d√≠a ${format(date, "EEEE d 'de' MMMM", { locale: es })} como d√≠a eventual`,
                                      });
                                      
                                      // No es necesario recargar la p√°gina, React Query se encargar√° de actualizar la UI autom√°ticamente
                                    },
                                    onError: (error) => {
                                      console.error("Error al agregar d√≠a eventual:", error);
                                      toast({
                                        title: "Error al agregar d√≠a eventual",
                                        description: "Ocurri√≥ un error al intentar guardar el d√≠a eventual",
                                        variant: "destructive"
                                      });
                                    }
                                  });
                                } catch (error) {
                                  console.error("Error al procesar d√≠a eventual:", error);
                                  toast({
                                    title: "Error al procesar fecha",
                                    description: "No se pudo procesar la fecha seleccionada",
                                    variant: "destructive"
                                  });
                                }
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                      
                      {scheduleConfig?.occasionalWorkDays && Array.isArray(scheduleConfig.occasionalWorkDays) && scheduleConfig.occasionalWorkDays.length > 0 ? (
                        <div className="grid gap-2">
                          <h4 className="text-sm font-medium whitespace-normal">D√≠as eventuales configurados:</h4>
                          <div className="flex flex-wrap gap-2">
                            {scheduleConfig.occasionalWorkDays?.map((dateStr) => {
                              // Asegurarse de que la fecha sea v√°lida
                              try {
                                // Usar formato consistente para evitar problemas con zonas horarias
                                const [year, month, day] = dateStr.split('-').map(num => parseInt(num, 10));
                                if (isNaN(year) || isNaN(month) || isNaN(day)) {
                                  console.error("Formato de fecha inv√°lido:", dateStr);
                                  return null;
                                }
                                
                                // Crear fecha usando UTC para consistencia
                                const date = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
                                
                                return (
                                  <div 
                                    key={dateStr}
                                    className="flex flex-col bg-green-50 text-green-700 p-2 rounded-md border border-green-300 cursor-pointer hover:bg-green-100 transition-colors"
                                    onClick={() => {
                                      try {
                                        // Parsear la fecha
                                        const [year, month, day] = dateStr.split('-').map(num => parseInt(num, 10));
                                        // Crear fecha con los componentes (mes es 0-indexado en JavaScript)
                                        const eventualDate = new Date(year, month - 1, day);
                                        
                                        // Navegar a la semana que contiene esta fecha
                                        setSelectedWeek(eventualDate);
                                        // Si estamos en vista de lista, cambiar a vista de calendario
                                        if (viewMode === "list") {
                                          setViewMode("calendar");
                                        }
                                        // Seleccionar esta fecha espec√≠fica
                                        setSelectedDate(eventualDate);
                                        
                                        toast({
                                          title: "Navegando a d√≠a eventual",
                                          description: `Mostrando ${format(eventualDate, "EEEE d 'de' MMMM", { locale: es })}`
                                        });
                                      } catch (error) {
                                        console.error("Error al navegar a d√≠a eventual:", error);
                                        toast({
                                          title: "Error de navegaci√≥n",
                                          description: "No se pudo navegar al d√≠a seleccionado",
                                          variant: "destructive"
                                        });
                                      }
                                    }}
                                  >
                                    <div className="flex items-center justify-between">
                                      {/* D√≠a de la semana m√°s visible */}
                                      <span className="font-bold text-sm capitalize">
                                        {format(date, "EEEE", { locale: es })}
                                      </span>
                                      <Button
                                        variant="destructive"
                                        size="sm"
                                        className="h-6 w-6 p-0 rounded-full flex items-center justify-center"
                                        onClick={(e) => {
                                          e.stopPropagation(); // Evitar que el evento burbujee
                                          e.preventDefault(); // Prevenir comportamiento por defecto
                                          console.log("Intentando eliminar d√≠a eventual:", dateStr);
                                          // Establecer el d√≠a a eliminar y mostrar el di√°logo de confirmaci√≥n
                                          setDayToRemove(dateStr);
                                          setShowRemoveConfirmDialog(true);
                                        }}
                                      >
                                        <X className="h-3 w-3" />
                                      </Button>
                                    </div>
                                    {/* Fecha completa en una segunda l√≠nea */}
                                    <span className="text-xs mt-1 font-semibold">
                                      {format(date, "d 'de' MMMM, yyyy", { locale: es })}
                                    </span>
                                  </div>
                                );
                              } catch (error) {
                                console.error("Error al procesar fecha:", dateStr, error);
                                return null;
                              }
                            })}
                          </div>
                        </div>
                      ) : (
                        <div className="text-sm text-muted-foreground italic">
                          No hay d√≠as eventuales configurados
                        </div>
                      )}
                    </div>
                  </div>

                  <DialogFooter>
                    <Button
                      type="submit"
                      disabled={updateScheduleMutation.isPending}
                    >
                      {updateScheduleMutation.isPending
                        ? "Guardando..."
                        : "Guardar cambios"}
                    </Button>
                  </DialogFooter>
                </form>
              </Form>
            </TabsContent>

            <TabsContent value="vacation" className="space-y-4 mt-4">
              <div className="space-y-6">
                <div>
                  <h3 className="font-medium mb-4">Per√≠odo de Vacaciones</h3>
                  <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <div className="font-medium text-sm">Desde</div>
                      <Calendar
                        mode="single"
                        selected={vacationStart}
                        onSelect={setVacationStart}
                        disabled={(date) => isBefore(date, new Date())}
                        className="rounded-md border"
                      />
                    </div>
                    <div className="space-y-2">
                      <div className="font-medium text-sm">Hasta</div>
                      <Calendar
                        mode="single"
                        selected={vacationEnd}
                        onSelect={setVacationEnd}
                        disabled={(date) =>
                          isBefore(date, new Date()) ||
                          (vacationStart ? isBefore(date, vacationStart) : false)
                        }
                        className="rounded-md border"
                      />
                    </div>
                  </div>
                </div>

                <div className="flex justify-end">
                  <Button
                    onClick={() => {
                      if (vacationStart && vacationEnd) {
                        updateScheduleMutation.mutate({
                          workDays: scheduleConfig?.workDays || [],
                          startTime: scheduleConfig?.startTime || "09:00",
                          endTime: scheduleConfig?.endTime || "17:00",
                          vacationPeriods: [
                            {
                              start: vacationStart.toISOString(),
                              end: vacationEnd.toISOString(),
                            },
                          ],
                        });
                      }
                    }}
                    disabled={
                      !vacationStart ||
                      !vacationEnd ||
                      updateScheduleMutation.isPending
                    }
                  >
                    {updateScheduleMutation.isPending
                      ? "Guardando..."
                      : "Guardar per√≠odo de vacaciones"}
                  </Button>
                </div>
              </div>
            </TabsContent>
            
            <TabsContent value="google-calendar" className="space-y-4 mt-4">
              <GoogleCalendarStatus />
            </TabsContent>

            <TabsContent value="messages" className="space-y-4 mt-4">
              <PatientMessageConfig
                messages={patientMessages}
                onSave={(message) => saveMessageMutation.mutate(message)}
                onDelete={(id) => deleteMessageMutation.mutate(id)}
              />
            </TabsContent>

            <TabsContent value="account" className="space-y-4 mt-4">
              <AccountSettings />
            </TabsContent>
          </Tabs>
        </DialogContent>
      </Dialog>

      {/* Reemplazamos el di√°logo de edici√≥n con un componente NewQuickAppointmentForm */}
      {editingAppointment && (
        <NewQuickAppointmentForm
          date={new Date(editingAppointment.appointmentTime)}
          timeStr={format(new Date(editingAppointment.appointmentTime), 'HH:mm')}
          onSubmit={(data: InsertAppointment) => {
            editMutation.mutate({
              id: editingAppointment.id,
              data: data
            });
          }}
          onCancel={() => {
            setEditingAppointment(null);
            // Reset form cuando se cierra el formulario
            form.reset({
              patientName: "",
              email: "",
              phone: "",
              serviceType: "Consulta",
              obraSocial: "Particular",
              isFirstTime: false,
              notes: "",
              appointmentTime: new Date(),
            });
            setSelectedDate(null);
            setSelectedTime(null);
          }}
          onDelete={(id: number) => deleteMutation.mutate(id)}
          isPending={editMutation.isPending}
          initialData={editingAppointment}
          mode="edit"
        />
      )}

      <Dialog
        open={showNewAppointment}
        onOpenChange={(open) => {
          setShowNewAppointment(open);
          if (!open && editingAppointment) {
            setEditingAppointment(null);
            form.reset({
              patientName: "",
              email: "",
              phone: "",
              serviceType: "Consulta",
              obraSocial: "Particular",
              isFirstTime: false,
              notes: "",
              appointmentTime: new Date(),
            });
            setSelectedDate(null);
            setSelectedTime(null);
          }
        }}
      >
        <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto border-primary/10 flex flex-col" style={{marginTop: '30px'}}>
          <DialogHeader>
            <DialogTitle>Nuevo Turno</DialogTitle>
            <DialogDescription>
              Complete el formulario para agendar un nuevo turno.
            </DialogDescription>
          </DialogHeader>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="appointmentTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Fecha y Hora</FormLabel>
                    <div className="space-y-4">
                      <Select
                        value={selectedDate instanceof Date && !isNaN(selectedDate.getTime()) ? selectedDate.toISOString() : ""}
                        onValueChange={(value) => {
                          if (value) {
                            try {
                              // Parse the ISO string to get a date
                              const parsedDate = new Date(value);

                              if (!isNaN(parsedDate.getTime())) {
                                // Create a new date with just the date parts to avoid time zone issues
                                const year = parsedDate.getFullYear();
                                const month = parsedDate.getMonth();
                                const day = parsedDate.getDate();

                                // Create clean date at midnight
                                const newDate = new Date(year, month, day, 0, 0, 0, 0);

                                console.log("Selected date from dropdown:", 
                                  value,
                                  "Parsed components:", year, month + 1, day,
                                  "New date object:", newDate.toISOString());

                                setSelectedDate(newDate);
                                setSelectedTime(null);

                                // Clear the appointment time until a time slot is selected
                                field.onChange(undefined);
                              }
                            } catch (err) {
                              console.log("Error parsing date:", err, "Value:", value);
                            }
                          }
                        }}
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Seleccionar fecha">
                            {selectedDate &&
                              format(selectedDate, "EEEE d 'de' MMMM", {
                                locale: es,
                              })}
                          </SelectValue>
                        </SelectTrigger>
                        <SelectContent>
                          {availableDates.map((date) => (
                            <SelectItem
                              key={date.toISOString()}
                              value={date.toISOString()}
                            >
                              {format(date, "EEEE d 'de' MMMM", { locale: es })}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>

                      {selectedDate && (
                        <div className="space-y-3">
                          {viewMode === "calendar" && selectedTime ? (
                            <div className="bg-secondary/20 p-4 rounded-lg">
                              <h3 className="font-medium flex items-center gap-2">
                                <Clock className="w-4 h-4" />
                                Horario seleccionado
                              </h3>
                              <div className="mt-2 flex items-center">
                                <div className="p-2 rounded bg-primary text-white font-medium text-center">
                                  {selectedTime} hs
                                </div>
                                <div className="ml-3 text-sm text-muted-foreground">
                                  {format(selectedDate, "EEEE d 'de' MMMM", { locale: es })}
                                </div>
                              </div>
                            </div>
                          ) : (
                            <>
                              <h3 className="font-medium flex items-center gap-2">
                                <Clock className="w-4 h-4" />
                                Horarios disponibles
                              </h3>
                              <div className="grid grid-cols-4 gap-2">
                                {selectedDate && getAvailableTimeSlots(selectedDate).map((slot) => {
                                  // Format time string with leading zeros for consistency
                                  const timeStr = `${slot.hour.toString().padStart(2, '0')}:${slot.minute === 0 ? '00' : slot.minute}`;

                                  // Check if this specific time slot is available
                                  const slotDate = new Date(selectedDate);
                                  slotDate.setHours(slot.hour, slot.minute, 0, 0);

                                  // For appointment being edited, consider its time slot as available
                                  let isAvailable = true;

                                  if (!editingAppointment) {
                                    // For new appointments, check if the slot is available
                                    isAvailable = !appointments.some(apt => {
                                      const aptTime = new Date(apt.appointmentTime);

                                      // Check for exact time slot conflict
                                      const exactMatch = isSameDay(aptTime, slotDate) && 
                                            aptTime.getHours() === slot.hour && 
                                            aptTime.getMinutes() === slot.minute;

                                      // Check for adjacent conflicts with special services
                                      const isSpecialService = apt.serviceType === "Extracci√≥n & Colocaci√≥n de DIU" || apt.serviceType === "Terapia de Ginecolog√≠a Regenerativa";

                                      // If it's a special service, only block slots before the appointment
                                      if (isSpecialService && isSameDay(aptTime, slotDate)) {
                                        // Calculate time in minutes for comparison
                                        const slotTimeInMinutes = slot.hour * 60 + slot.minute;
                                        const aptTimeInMinutes = aptTime.getHours() * 60 + aptTime.getMinutes();

                                        // Block only slots before DIU services (not after)
                                        const isSlotBeforeDIU = slotTimeInMinutes <= aptTimeInMinutes && (aptTimeInMinutes - slotTimeInMinutes <= 30);
                                        return exactMatch || isSlotBeforeDIU;
                                      }

                                      return exactMatch;
                                    });
                                  } else {
                                    // For edited appointments, consider its own slot as available
                                    isAvailable = !appointments.some(apt => {
                                      if (apt.id === editingAppointment.id) return false;

                                      const aptTime = new Date(apt.appointmentTime);

                                      // Check for exact time slot conflict
                                      const exactMatch = isSameDay(aptTime, slotDate) && 
                                            aptTime.getHours() === slot.hour && 
                                            aptTime.getMinutes() === slot.minute;

                                      // Check for adjacent conflicts with special services
                                      const isSpecialService = apt.serviceType === "Extracci√≥n & Colocaci√≥n de DIU" || apt.serviceType === "Terapia de Ginecolog√≠a Regenerativa";

                                      // If it's a special service, only block slots before the appointment
                                      if (isSpecialService && isSameDay(aptTime, slotDate)) {
                                        // Calculate time in minutes for comparison
                                        const slotTimeInMinutes = slot.hour * 60 + slot.minute;
                                        const aptTimeInMinutes = aptTime.getHours() * 60 + aptTime.getMinutes();

                                        // Block only slots before DIU services (not after)
                                        const isSlotBeforeDIU = slotTimeInMinutes <= aptTimeInMinutes && (aptTimeInMinutes - slotTimeInMinutes <= 30);
                                        return exactMatch || isSlotBeforeDIU;
                                      }

                                      return exactMatch;
                                    });
                                  }

                                  // Check if the current time matches the selected time (accounting for potential format differences)
                                  const isSelected = selectedTime === timeStr;

                                  return (
                                    <button
                                      key={timeStr}
                                      type="button"
                                      disabled={!isAvailable && !editingAppointment}
                                      onClick={() => {
                                        // Llamar a handleSlotSelect con el flag para abrir el formulario directamente
                                        handleSlotSelect(timeStr, true);
                                      }}
                                      className={cn(
                                        "p-2 rounded text-sm transition-colors",
                                        isSelected
                                          ? "bg-primary text-white"
                                          : isAvailable
                                            ? "bg-secondary hover:bg-secondary/80"
                                            : "bg-muted cursor-not-allowed",
                                      )}
                                    >
                                      {timeStr}
                                    </button>
                                  );
                                })}
                              </div>
                            </>
                          )}
                        </div>
                      )}
                      <FormMessage />
                    </div>
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="patientName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Nombre del Paciente</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="phone"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Tel√©fono</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="serviceType"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Tipo de Servicio</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Seleccione el tipo de servicio" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="Consulta">Consulta</SelectItem>
                        <SelectItem value="Consulta & PAP">
                          Consulta & PAP
                         <SelectItem value="Terapia de Ginecolog√≠a Regenerativa">
                          Terapia de Ginecolog√≠a Regenerativa
                        </SelectItem>
                        </SelectItem>
                        <SelectItem value="Extracci√≥n & Colocaci√≥n de DIU">
                          Extracci√≥n & Colocaci√≥n de DIU
                        </SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="obraSocial"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Obra Social</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Seleccione la obra social" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="Particular">Particular</SelectItem>
                        <SelectItem value="OSDE">OSDE</SelectItem>
                        <SelectItem value="Swiss Medical">
                          Swiss Medical
                        </SelectItem>
                        <SelectItem value="Galeno">Galeno</SelectItem>
                        <SelectItem value="Medif√©">Medif√©</SelectItem>
                        <SelectItem value="IOMA">IOMA</SelectItem>
                        <SelectItem value="Other">Otra</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="isFirstTime"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-center gap-2 space-y-0">
                    <FormControl>
                      <Checkbox
                        checked={field.value}
                        onCheckedChange={field.onChange}
                      />
                    </FormControl>
                    <FormLabel className="text-sm font-normal">
                      Primera consulta
                    </FormLabel>
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="notes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Notas</FormLabel>
                    <FormControl>
                      <Textarea {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <DialogFooter className="mt-6 flex items-center justify-end gap-2 sticky bottom-0 bg-background pt-2 pb-2">
                <Button
                  variant="outline"
                  onClick={() => setShowNewAppointment(false)}
                >
                  Cancelar
                </Button>
                <Button
                  type="submit"
                  disabled={editingAppointment ? editMutation.isPending : createAppointmentMutation.isPending}
                >
                  {(editingAppointment ? editMutation.isPending : createAppointmentMutation.isPending) ? (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  ) : null}
                  {editingAppointment ? "Guardar Cambios" : "Guardar"}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
      <Dialog
        open={!!showClinicalHistory}
        onOpenChange={(open) => !open && setShowClinicalHistory(null)}
      >
        <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto border-primary/10">
          <DialogHeader>
            <DialogTitle>Historia Cl√≠nica del Paciente</DialogTitle>
          </DialogHeader>
          {showClinicalHistory && (
            <ClinicalHistory patientId={showClinicalHistory} />
          )}
        </DialogContent>
      </Dialog>

      {/* Di√°logo para a√±adir un motivo al bloquear un d√≠a */}
      <AlertDialog open={showBlockDayDialog} onOpenChange={setShowBlockDayDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bloquear d√≠a</AlertDialogTitle>
            <AlertDialogDescription>
              Ingrese el motivo por el cual este d√≠a no estar√° disponible para citas.
              {dayToBlock && (
                <p className="mt-2 font-medium">
                  Fecha: {format(dayToBlock, "EEEE d 'de' MMMM yyyy", { locale: es })}
                </p>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="p-4">
            <Textarea
              value={blockReason}
              onChange={(e) => setBlockReason(e.target.value)}
              placeholder="Ej: Feriado, Vacaciones, Capacitaci√≥n, etc."
              className="min-h-[80px]"
            />
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => {
              setDayToBlock(null);
              setBlockReason("");
            }}>
              Cancelar
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleBlockDay}>
              Confirmar bloqueo
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Di√°logo para configurar horarios espec√≠ficos de d√≠as eventuales */}
      <AlertDialog open={showOccasionalDayTimeDialog} onOpenChange={setShowOccasionalDayTimeDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Configurar horario para d√≠a eventual</AlertDialogTitle>
            <AlertDialogDescription>
              Configure el horario espec√≠fico para este d√≠a de atenci√≥n eventual.
            </AlertDialogDescription>
            {newOccasionalDay && (
              <div className="mt-2 font-medium">
                {(() => {
                  // Crear formato de fecha consistente
                  const [year, month, day] = newOccasionalDay.split('-').map(num => parseInt(num, 10));
                  // Crear fecha usando UTC para consistencia
                  const date = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
                  return `Fecha: ${format(date, "EEEE d 'de' MMMM yyyy", { locale: es })}`;
                })()}
              </div>
            )}
          </AlertDialogHeader>
          
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="occasional-start-time">Hora de inicio</Label>
                <Input 
                  id="occasional-start-time" 
                  type="time" 
                  value={occasionalDayStartTime}
                  onChange={(e) => setOccasionalDayStartTime(e.target.value)}
                />
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="occasional-end-time">Hora de fin</Label>
                <Input 
                  id="occasional-end-time" 
                  type="time"
                  value={occasionalDayEndTime}
                  onChange={(e) => setOccasionalDayEndTime(e.target.value)}
                />
              </div>
            </div>
          </div>
          
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => {
              setNewOccasionalDay(null);
            }}>
              Cancelar
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                if (!newOccasionalDay || !scheduleConfig) return;
                
                try {
                  // Agregar el d√≠a a la lista de d√≠as eventuales
                  const currentOccasionalDays = scheduleConfig.occasionalWorkDays || [];
                  const newOccasionalDays = [...currentOccasionalDays, newOccasionalDay];
                  
                  // Configurar los horarios espec√≠ficos para este d√≠a
                  const currentOccasionalDayTimes = scheduleConfig.occasionalWorkDayTimes || {};
                  const newOccasionalDayTimes = {
                    ...currentOccasionalDayTimes,
                    [newOccasionalDay]: {
                      startTime: occasionalDayStartTime,
                      endTime: occasionalDayEndTime
                    }
                  };
                  
                  console.log("üìÖ Agregando d√≠a eventual con horario espec√≠fico:", {
                    day: newOccasionalDay,
                    startTime: occasionalDayStartTime,
                    endTime: occasionalDayEndTime
                  });
                  
                  // Actualizar la configuraci√≥n
                  updateScheduleMutation.mutate({
                    occasionalWorkDays: newOccasionalDays,
                    occasionalWorkDayTimes: newOccasionalDayTimes
                  }, {
                    onSuccess: () => {
                      console.log("‚úÖ D√≠a eventual con horario espec√≠fico agregado correctamente");
                      
                      // Formatear fecha para mensaje
                      const [year, month, day] = newOccasionalDay.split('-').map(num => parseInt(num, 10));
                      const date = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
                      
                      toast({
                        title: "D√≠a eventual agregado",
                        description: `Se agreg√≥ el d√≠a ${format(date, "EEEE d 'de' MMMM", { locale: es })} con horario ${occasionalDayStartTime} - ${occasionalDayEndTime}`,
                      });
                      
                      // Cerrar el di√°logo y limpiar el estado
                      setShowOccasionalDayTimeDialog(false);
                      setNewOccasionalDay(null);
                    },
                    onError: (error) => {
                      console.error("Error al agregar d√≠a eventual con horario espec√≠fico:", error);
                      toast({
                        title: "Error al agregar d√≠a eventual",
                        description: "Ocurri√≥ un error al intentar guardar el d√≠a eventual con horario espec√≠fico",
                        variant: "destructive"
                      });
                    }
                  });
                } catch (error) {
                  console.error("Error al procesar d√≠a eventual con horario espec√≠fico:", error);
                  toast({
                    title: "Error al procesar datos",
                    description: "No se pudo procesar la configuraci√≥n de horario espec√≠fico",
                    variant: "destructive"
                  });
                }
              }}
            >
              Guardar horario
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      
      {/* Di√°logo de confirmaci√≥n para eliminar d√≠as eventuales */}
      <AlertDialog open={showRemoveConfirmDialog} onOpenChange={setShowRemoveConfirmDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Eliminar d√≠a eventual</AlertDialogTitle>
            <AlertDialogDescription>
              ¬øEst√° seguro que desea eliminar este d√≠a eventual del calendario?
            </AlertDialogDescription>
            {dayToRemove && (
              <div className="mt-2 font-medium">
                {(() => {
                  // Usar formato consistente para evitar problemas con zonas horarias
                  const [year, month, day] = dayToRemove.split('-').map(num => parseInt(num, 10));
                  // Crear fecha usando UTC para consistencia
                  const date = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
                  return `Fecha: ${format(date, "EEEE d 'de' MMMM yyyy", { locale: es })}`;
                })()}
              </div>
            )}
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => {
              setShowRemoveConfirmDialog(false);
              setDayToRemove(null);
            }}>
              Cancelar
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                if (dayToRemove && scheduleConfig?.occasionalWorkDays) {
                  console.log("üîç DEBUG: Iniciando proceso de eliminaci√≥n de d√≠a eventual");
                  console.log("üîç DEBUG: D√≠a a eliminar:", dayToRemove);
                  
                  try {
                    // Proceso detallado para una eliminaci√≥n m√°s segura
                    // 1. Formatear el d√≠a a eliminar para que coincida exactamente con el formato guardado
                    const dateToRemove = dayToRemove.trim();
                    
                    // Verificaci√≥n detallada
                    console.log("üîç DEBUG: Lista actual de d√≠as eventuales:", JSON.stringify(scheduleConfig.occasionalWorkDays));
                    console.log("üîç DEBUG: D√≠a a eliminar (procesado):", JSON.stringify(dateToRemove));
                    
                    // 2. Crear una nueva lista SIN el d√≠a que queremos eliminar
                    const newOccasionalDays = Array.isArray(scheduleConfig.occasionalWorkDays) 
                      ? scheduleConfig.occasionalWorkDays.filter(day => {
                          const match = day === dateToRemove;
                          console.log(`üîç DEBUG: Comparando '${day}' con '${dateToRemove}' = ${match ? 'IGUAL (se eliminar√°)' : 'DIFERENTE (se mantiene)'}`);
                          return day !== dateToRemove;
                        }) 
                      : [];
                    
                    console.log("üîç DEBUG: Nueva lista de d√≠as eventuales:", JSON.stringify(newOccasionalDays));
                    
                    // 3. Verificar que la lista haya cambiado (eliminaci√≥n exitosa)
                    if (scheduleConfig.occasionalWorkDays.length === newOccasionalDays.length) {
                      console.warn("‚ö†Ô∏è ADVERTENCIA: No se encontr√≥ el d√≠a en la lista para eliminar");
                      
                      // Intento alternativo con comparaci√≥n menos estricta
                      const newOccasionalDaysAlt = scheduleConfig.occasionalWorkDays.filter(day => {
                        // Normalizar fechas para comparaci√≥n menos estricta
                        return day.replace(/\s+/g, '') !== dateToRemove.replace(/\s+/g, '');
                      });
                      
                      if (newOccasionalDaysAlt.length < scheduleConfig.occasionalWorkDays.length) {
                        console.log("üîç DEBUG: Eliminaci√≥n exitosa con m√©todo alternativo");
                        // Utilizar el resultado alternativo
                        updateScheduleMutation.mutate({
                          occasionalWorkDays: newOccasionalDaysAlt
                        }, {
                          onSuccess: () => {
                            console.log("‚úÖ D√≠a eventual eliminado correctamente");
                            
                            // Cerrar el di√°logo y limpiar el estado
                            setShowRemoveConfirmDialog(false);
                            setDayToRemove(null);
                            
                            // Notificar al usuario con un toast
                            toast({
                              title: "D√≠a eventual eliminado correctamente",
                              description: "El d√≠a ha sido eliminado de la lista de d√≠as eventuales",
                            });
                            
                            // No necesitamos recargar la p√°gina, React Query se encargar√° de actualizar la UI
                          }
                        });
                        return; // Salir de la funci√≥n
                      }
                      
                      toast({
                        title: "No se pudo eliminar el d√≠a eventual",
                        description: "No se encontr√≥ el d√≠a en la lista. Intente nuevamente.",
                        variant: "destructive"
                      });
                      
                      return; // Salir de la funci√≥n
                    }
                    
                    // 4. Enviar la actualizaci√≥n
                    console.log("üîç Enviando actualizaci√≥n al servidor");
                    updateScheduleMutation.mutate({
                      occasionalWorkDays: newOccasionalDays
                    }, {
                      onSuccess: () => {
                        console.log("‚úÖ D√≠a eventual eliminado correctamente");
                        
                        toast({
                          title: "D√≠a eventual eliminado correctamente",
                          description: "El d√≠a ha sido eliminado de la lista de d√≠as eventuales"
                        });
                        
                        // Cerrar el di√°logo
                        setShowRemoveConfirmDialog(false);
                        setDayToRemove(null);
                        
                        // No necesitamos recargar la p√°gina, React Query actualizar√° los datos autom√°ticamente
                      }
                    });
                  } catch (error) {
                    console.error("üî¥ ERROR durante la eliminaci√≥n del d√≠a eventual:", error);
                    toast({
                      title: "Error al eliminar d√≠a eventual",
                      description: "Ha ocurrido un error inesperado. Consulte la consola para m√°s detalles.",
                      variant: "destructive"
                    });
                  }
                }
              }}
            >
              Eliminar
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}