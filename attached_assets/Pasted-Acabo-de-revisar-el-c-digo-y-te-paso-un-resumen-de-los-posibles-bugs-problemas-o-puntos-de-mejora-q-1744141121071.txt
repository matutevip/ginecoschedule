Acabo de revisar el cÃ³digo y te paso un resumen de los posibles bugs, problemas o puntos de mejora que encontrÃ©:

ðŸž Posibles bugs o comportamientos inesperados
Seteo del horario en formulario (appointmentTime)

En varios lugares se hace setTimeout para asegurar que el valor se setea correctamente en el formulario. Esto indica que hay una condiciÃ³n de carrera, y puede causar bugs intermitentes si el valor no se setea correctamente.

âš ï¸ Sugerencia: consolidar lÃ³gica de seteo en un solo lugar y evitar el uso de setTimeout mÃºltiples veces para lo mismo.

Uso de form.getValues("appointmentTime") sin validar tipo

Aunque se usa instanceof Date, si el valor es un string ISO (como puede pasar al hacer .reset()), puede fallar la validaciÃ³n posterior.

âš ï¸ Mejor usar siempre new Date(value) y verificar con isNaN(date.getTime()) para garantizar que sea una fecha vÃ¡lida.

Chequeo de disponibilidad (isTimeSlotAvailable)

Usa aptTime.getHours() y aptTime.getMinutes() para comparar, pero no considera segundos ni milisegundos. Esto estÃ¡ bien, pero si algÃºn turno se guarda con segundos distintos de 0, puede fallar la comparaciÃ³n.

âœ… PodÃ©s asegurarte de normalizar aptTime con .setSeconds(0, 0) antes de comparar.

EdiciÃ³n de turnos: no se verifica si editingAppointment sigue siendo vÃ¡lido

Si el turno ya fue eliminado del backend, form.reset() podrÃ­a setear un estado inconsistente. Se podrÃ­a agregar una verificaciÃ³n previa antes de llenar el form.

âš™ï¸ Mejoras y recomendaciones generales
Desacoplar lÃ³gica de fechas y slots

Hay una gran cantidad de lÃ³gica duplicada entre los distintos modos (calendar, list, etc.) para setear appointmentTime, lo que complica el mantenimiento.

âœ¨ PodrÃ­as crear una funciÃ³n utilitaria tipo:

ts
Copy
Edit
function buildDateWithTime(baseDate: Date, timeStr: string): Date { ... }
FunciÃ³n handleSlotSelect hace demasiado

Setea estado, form, referencias y decide si abrir modal. Es propensa a errores por side effects.

âœ‚ï¸ PodrÃ­as separarla en:

selectSlot(slot)

openAppointmentDialog(slot)

fillForm(slot)

Paginar con appointmentsPage sin useMemo puede recalcular demÃ¡s

Aunque no es grave, si tenÃ©s muchos datos podrÃ­as usar useMemo para evitar recalcular sortedAppointments.

availableDates puede incluir dÃ­as sin horarios vÃ¡lidos

Lo seteÃ¡s basado en dÃ­as laborables, pero no verificÃ¡s si tienen al menos un horario disponible (por citas ocupadas).

ðŸ” Si querÃ©s que refleje sÃ³lo dÃ­as con disponibilidad real, podÃ©s filtrarlos con getAvailableTimeSlots(day).length > 0.

âœ… En resumen
Tu cÃ³digo estÃ¡ muy bien estructurado y completo. Las sugerencias son mÃ¡s para evitar bugs sutiles en el futuro o mejorar el mantenimiento. Si querÃ©s, te puedo ayudar a refactorizar alguna de las partes crÃ­ticas como la lÃ³gica de appointmentTime o los slots disponibles.

Â¿QuerÃ©s que prepare una refactor sugerida para algÃºn fragmento?







You said:
si por favor refactoriza appointmentTime y los slots


ChatGPT said:
Â¡Perfecto, Mati! Vamos a refactorizar dos partes clave:

ðŸ”§ Objetivo
Consolidar la lÃ³gica de generaciÃ³n de appointmentTime (fecha + hora).

Simplificar y centralizar el manejo de slots disponibles.

âœ… 1. FunciÃ³n utilitaria para construir appointmentTime
Creamos una funciÃ³n Ãºnica para armar correctamente la fecha + hora sin repetir lÃ³gica ni setTimeouts.

ts
Copy
Edit
function buildAppointmentDate(date: Date, time: string): Date {
  const [hoursStr, minutesStr] = time.split(":");
  const hours = parseInt(hoursStr, 10);
  const minutes = parseInt(minutesStr, 10);
  
  const newDate = new Date(date);
  newDate.setHours(hours, minutes, 0, 0);
  return newDate;
}
ðŸ“Œ UsÃ¡ esta funciÃ³n en lugar de repetir setHours() y .split(":") por todos lados.

âœ… 2. ValidaciÃ³n centralizada de disponibilidad
ts
Copy
Edit
function isSlotAvailable(date: Date, time: string, appointments: Appointment[], editingId?: number): boolean {
  const appointmentDateTime = buildAppointmentDate(date, time);

  return !appointments.some((apt) => {
    if (editingId && apt.id === editingId) return false;
    
    const aptDate = new Date(apt.appointmentTime);
    return (
      isSameDay(aptDate, appointmentDateTime) &&
      aptDate.getHours() === appointmentDateTime.getHours() &&
      aptDate.getMinutes() === appointmentDateTime.getMinutes()
    );
  });
}
âœ… 3. Generador de slots disponibles para un dÃ­a
ts
Copy
Edit
function getAvailableTimeSlotsForDate(
  date: Date, 
  scheduleConfig: ScheduleConfig, 
  appointments: Appointment[], 
  editingId?: number
): string[] {
  const [startHour, startMinute = 0] = scheduleConfig.startTime.split(":").map(Number);
  const [endHour, endMinute = 0] = scheduleConfig.endTime.split(":").map(Number);

  const startTotal = startHour * 60 + startMinute;
  const endTotal = endHour * 60 + endMinute;

  const availableSlots: string[] = [];

  for (let minutes = startTotal; minutes < endTotal; minutes += 30) {
    const hour = Math.floor(minutes / 60);
    const minute = minutes % 60;
    const slotStr = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`;

    if (isSlotAvailable(date, slotStr, appointments, editingId)) {
      availableSlots.push(slotStr);
    }
  }

  return availableSlots;
}
âœ… 4. En el componente: reemplazo de lÃ³gica duplicada
Por ejemplo, en lugar de:

ts
Copy
Edit
const [hours, minutes] = selectedTime.split(":").map(Number);
const date = new Date(selectedDate);
date.setHours(hours, minutes);
form.setValue("appointmentTime", date);
â†’ ahora simplemente hacÃ©s:

ts
Copy
Edit
const appointmentDate = buildAppointmentDate(selectedDate, selectedTime);
form.setValue("appointmentTime", appointmentDate);